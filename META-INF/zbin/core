#!/sbin/sh
#Dynamic Installer by @BlassGO
#Also uses code from @osm0sis and @topjohnwu

unmount() { ( umount "$1" || umount -l "$1";) 2>/dev/null; is_mounted "$1" && return 1 || return 0; }

write_raw_image() { local bs; if is_number $(string remove M "$extraction_speed"); then bs=$extraction_speed; else bs=1048576; fi; dd if="$1" of="$2" bs=$bs; }

is_substring() { if [[ "$2" == *"$1"* ]]; then true; else false; fi; }

is_less() { compare $1 '<' $2 ;}

is_greater() { compare $1 '>' $2 ;}

is_equal() { if [[ "$1" == "$2" ]]; then true; else false; fi; }

is_zip() { xxd -p "$1" | head -n1 | grep -q "504b0304"; }

is_gzip() { xxd -p "$1" | head -n1 | grep -q "1f8b08"; }

is_bzip() { xxd -p "$1" | head -n1 | grep -q "425a"; }

is_xz() { xxd -p "$1" | head -n1 | grep -q "fd377a585a00"; }

is_tar() { local offset; offset=$(echo $(repeat 20 0)7573746172); xxd -p "$1" | grep -q "$offset"; }

show_progress() { if ! $BOOTMODE; then echo "progress $1 $2" >> $OUTFD; fi }

apply_patch() { LD_LIBRARY_PATH=/system/lib$base_lib applypatch "$@"; }

apply_patch_check() { LD_LIBRARY_PATH=/system/lib$base_lib applypatch -c "$@"; }

apply_patch_space() { LD_LIBRARY_PATH=/system/lib$base_lib applypatch -s $1; }

rename() { mv -f "$1" "$2"; }

delete() { rm -f "$@"; }

delete_recursive() { rm -rf "$@"; }

repeat() { printf %${1}s | sed "s/ /$(string escape "$2")/g"; }

calc() { awk "BEGIN{print $*}"; }

compare() { awk "BEGIN{if (!($*)) exit 1}"; }

exist() {
   local func try count=0 restore flag file folder any
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       file)
       file=true
       shift
       ;;
       folder)
       folder=true
       shift
       ;;
       any)
       any=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   func=$#
   if [[ "$func" == "0" ]]; then func=1; fi
   if [[ -z "$folder" && -z "$file" && -z "$any" ]]; then any=true; fi
   for try in "$@"; do
      if [[ -n "$file" && -f "$try" ]]; then count=$(( $count + 1 )); fi
      if [[ -n "$any" && -e "$try" ]]; then count=$(( $count + 1 )); fi
      if [[ -n "$folder" && -d "$try" ]]; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

check_content() {
   local array file content func count=0
   array=( "$@" )
   file=${array[${#array[@]} - 1]}
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   if ! is_zip "$file"; then echo "check_content: $file inst a ZIP " && return 1; fi
   unset "array[${#array[@]}-1]"
   func=${#array[@]}
   if [[ "$func" == "0" ]]; then func=1; fi
   for content in "${array[@]}"; do
      if unzip -l "$file" | grep -q "$content"; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

is_valid() {
   local count=0 func try
   func=$#
   if [[ "$func" == "0" ]]; then func=1; fi
   for try in "$@"; do
      if [ -e "$try" ] && grep -q '[^[:space:]]' "$try"; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

defined() {
   local count=0 func try
   func=$#
   if [[ "$func" == "0" ]]; then func=1; fi
   for try in "$@"; do
      if [ -n "$(checkvar "$try")" ]; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

undefined() {
   local count=0 func try
   func=$#
   if [[ "$func" == "0" ]]; then func=1; fi
   for try in "$@"; do
      if [ -z "$(checkvar "$try")" ]; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

copy() {
   if ! $(cp -prf "$1" "$2" 2>/dev/null || [ ! -d "$(dirname "$2")" ] && mkdir -p "$(dirname "$2")" && cp -prf "$1" "$2"); then
      if [[ -d "$(dirname "$2")" && -z "$(ls -A "$(dirname "$2")")" ]]; then
         rm -rf "$(dirname "$2")"
         return 1
      else
         return 1
      fi
   else
      return 0
   fi
}

move() {
   if ! $(mv -f "$1" "$2" 2>/dev/null || [ ! -d "$(dirname "$2")" ] && mkdir -p "$(dirname "$2")" && mv -f "$1" "$2"); then
      if [[ -d "$(dirname "$2")" && -z "$(ls -A "$(dirname "$2")")" ]]; then
         rm -rf "$(dirname "$2")"
         return 1
      else
         return 1
      fi
   else
      return 0
   fi
}

contains() {
   local array file content func count=0
   array=( "$@" )
   file=${array[${#array[@]} - 1]}
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   unset "array[${#array[@]}-1]"
   func=${#array[@]}
   if [[ "$func" == "0" ]]; then func=1; fi
   for content in "${array[@]}"; do
      if grep -q "$content" "$file"; then count=$(( $count + 1 )); fi
   done
   if [[ "$count" == "$func" ]]; then true; else false; fi
}

contains_array() { local e match="$1"; shift; for e; do [[ "$e" == "$match" ]] && return 0; done; return 1; }

get_array() { local e match="$1"; shift; for e; do [[ "$e" == *"$match"* ]] && echo "$e" && return 0; done; return 1; }

abort() {
   ui_print "$@"
   umount_all
   [ -n "$MODPATH" ] && delete_recursive "$MODPATH"
   remove_tmp
   restore_env
   exit 130
}

bin_info() {
   local check
   if ! grep -wm1 "$1" "$l/info.txt" 2>/dev/null; then
      if [ -f "$1" ]; then
         check=$(binarch "$1")
         if [[ $check == 64bits ]]; then echo "$(basename "$1"): 64bits"
         elif [[ $check == 32bits ]]; then echo "$(basename "$1"): 32bits"
         else echo "$(basename "$1"): Unknown"
         fi
      elif [ -f "$(command -v "$1")" ]; then
         check=$(binarch "$(command -v "$1")")
         if [[ $check == 64bits ]]; then echo "$1: 64bits"
         elif [[ $check == 32bits ]]; then echo "$1: 32bits"
         else echo "$1: Unknown"
         fi
      else return 1
      fi
   fi
}

wipe() {
   #wipe system vendor data
   local wipe return=0
   for wipe in "$@"; do
      if [[ "$wipe" == "data" ]]; then
         if ! try_mount -e -rw /data; then echo "CANT WIPE: /data" && return=1 && continue; fi
         echo2 " -- Wiping /data"
         find /data -mindepth 1 ! -regex "/data/media.*" -delete
      elif [[ "$wipe" == "userdata" ]]; then
         if ! try_mount -e -rw /data; then echo "CANT WIPE: /data and /data/media" && return=1 && continue; fi
         echo2 " -- Wiping /data and /data/media"
         rm -rf /data/*
      elif [[ "$wipe" == "dalvik" ]]; then
         if ! try_mount -e -rw /data; then echo "CANT WIPE: /data/dalvik-cache" && return=1 && continue; fi
         echo2 " -- Wiping /data/dalvik-cache"
         rm -rf /data/dalvik-cache
      else
         if ! try_mount -rw "/$wipe"; then echo "CANT WIPE: /$wipe" && return=1 && continue; fi
         echo2 " -- Wiping /$wipe"
         rm -rf /$wipe/*
         unmount "/$wipe"
      fi
   done
   return $return
}

set_metadata() {
  local file i;
  file="$1";
  shift;
  while [ "$2" ]; do
    case $1 in
      uid) chown $2 "$file";;
      gid) chown :$2 "$file";;
      mode) chmod $2 "$file";;
      capabilities) twrp setcap "$file" $2;;
      selabel)
        chcon -h $2 "$file" || chcon $2 "$file";
      ;;
      *) ;;
    esac;
    shift 2;
  done;
}

update_file() {
   local file get newprop prop result propc xml test newprop2 space split
   local restore flag tmp huh save result save2 save3 TMP2
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift 3
       ;;
       -no-spaces|-ns)
       save2=("$1")
       shift
       ;;
       -p|-pattern)
       save3=("$1" "$2")
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   file="$2"
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   if [ ! -e "$1" ]; then echo "CANT FIND: $1" && return 1; fi
   start_tmp
   tmp="$TMP2/$(basename "$file")"
   cat "$file" > "$tmp"
   while IFS='' read -r prop || [[ -n "$prop" ]]; do
         huh+=("$prop")
   done < "$1"
   update_file_string "${save[@]}" "${save2[@]}" "${save3[@]}" "${huh[@]}" "$tmp"
   result=$?
   inject "$tmp" "$(dirname "$file")"
   end_tmp
   return $result
}

update_file_string() {
   local vars file array newprop prop propc xml result new old
   local restore flag d d2 huh tmp extract newprop2 backdir space space2 newspace nospace
   local p
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       d="$2"
       d2="$3"
       shift 3
       ;;
       -no-spaces|-ns)
       nospace=true
       shift
       ;;
       -p|-pattern)
       p="$2"
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   array=( "$@" )
   file=${array[${#array[@]} - 1]}
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   savestate old "$file"
   tmp="$TMP/$(basename "$file")"
   unset "array[${#array[@]}-1]"
   cat "$file" > "$tmp"
   if [ -n "$d" ]; then
      huh=$(cat "$file")
      backdir="$file"
      if [ -z "$p" ]; then
         extract=$(string complete_extract "$d" "$d2" "$huh")
      else
         extract=$(string -r -p "$p" complete_extract "$d" "$d2" "$huh")
      fi
      file="$tmp"
      if [ -n "$extract" ]; then echo "$extract" > "$tmp"; else echo "CANT GET CONTENT: $d $d2" && return 1; fi
   fi
   for prop in "${array[@]}"; do
         if [ -z "$prop" ]; then continue; fi
         newprop=
         propc=
         xml=
         space=
         space2=
         newspace=
         test "${prop#*=}" != "$prop" && propc=1
         test "${prop#*/>}" != "$prop" && xml=1
         test "${prop#*</}" != "$prop" && xml=1
         if [[ -n "$xml" && -n "$propc" ]]; then propc=0; fi
         if [[ "$xml" == "1" ]]; then
             newprop=$(string inside_symbol '="' '"' "$prop")
             newprop2=$(string inside_symbol ' ' ='"'$newprop'"' "$prop") 
             if [ -n "$newprop" ]; then
               if [[ $(grep -o "$newprop2" "$file" | wc -l) == "1"  ]]; then
                  newprop="$newprop2"
               elif ! is_substring "$newprop2" "$(grep -m1 "$newprop" "$file")"; then
                  newprop=
               fi
             fi
             if [[ -z "$newprop" || "$newprop" == "$prop" ]]; then
                if is_substring '</' "$prop"; then
                   newprop=$(echo "$prop" | sed -e 's/.*<\/\(.*\)>.*/\1/') 
                elif is_substring '/>' "$prop"; then
                   newprop=$(echo "$prop" | sed -e 's/.*<\(.*\)\/>.*/\1/')
                fi
             fi
             if [[ -n "$newprop" && "$newprop" != "$prop" ]]; then
                space=$(grep -m1 "$newprop" "$file" | cut -d'<' -f1)
                space2=$(echo "$prop" | cut -d'<' -f1)
                if [[ "$space" != "$space2" && -z "$nospace" ]]; then
                   newspace="$space"
                fi
             else
                newprop=
                echo2 " WARNING: Abnormal xml $prop"
             fi
         fi   
         if [[ "$propc" == "1" ]]; then  
             newprop=$(echo "$prop" | cut -d '=' -f1 | tr -d " ")
         fi  
         if [ -z "$newprop" ]; then continue; fi
         echo2 "::$newprop"
         prop=$(echo "${newspace}${prop}" | sed -e 's/[]\/$*.^[]/\\&/g')
         result=$(sed "s/.*$(string escape "$newprop").*/${prop}/" "$tmp")
         if [ ! -z "$result" ]; then echo "$result" > "$tmp"; fi
   done
   if [ -n "$d" ]; then
      file="$backdir"
      echo "${huh/$extract/$result}" > "$tmp"
   fi
   if ! is_valid "$tmp"; then echo2 " FATAL ERROR: Invalid $tmp " && return 1; fi
   inject "$tmp" "$(dirname "$file")"
   rm -f "$tmp"
   savestate new "$file"
   if [[ "$old" != "$new" ]]; then true; else false; fi
}

update_file_addon() {
   local restore flag save save2 save3
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift 3
       ;;
       -no-spaces|-ns)
       save2=("$1")
       shift
       ;;
       -p|-pattern)
       save3=("$1" "$2")
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   update_file "${save[@]}" "${save2[@]}" "${save3[@]}" "$addons/$1" "$2"
}

update_file_zip() {
   local restore flag save result save2 save3
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift 3
       ;;
       -no-spaces|-ns)
       save2=("$1")
       shift
       ;;
       -p|-pattern)
       save3=("$1" "$2")
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   package_extract_file "$1" "$TMP/$(basename "$1")"
   update_file "${save[@]}" "${save2[@]}" "${save3[@]}" "$TMP/$(basename "$1")" "$2"
   result=$?
   rm -f "$TMP/$(basename "$1")"
   return $result
}

force_update_file() {
   local file get newprop prop result propc xml test newprop2 space split
   local restore flag tmp huh save save2 save3 TMP2
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift 3
       ;;
       -no-spaces|-ns)
       save2=("$1")
       shift
       ;;
       -p|-pattern)
       save3=("$1" "$2")
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   file="$2"
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   if [ ! -e "$1" ]; then echo "CANT FIND: $1" && return 1; fi
   start_tmp
   tmp="$TMP2/$(basename "$file")"
   cat "$file" > "$tmp"
   while IFS='' read -r prop || [[ -n "$prop" ]]; do
         huh+=("$prop")
   done < "$1"
   force_update_file_string "${save[@]}" "${save2[@]}" "${save3[@]}" "${huh[@]}" "$tmp"
   result=$?
   inject "$tmp" "$(dirname "$file")"
   end_tmp
   return $result
}

force_update_file_string() {
   local vars file array newprop prop propc xml result old new
   local restore flag d d2 huh tmp extract newprop2 limit backdir space space2 newspace nospace
   local p
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       d="$2"
       d2="$3"
       shift 3
       ;;
       -no-spaces|-ns)
       nospace=true
       shift
       ;;
       -p|-pattern)
       p="$2"
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   array=( "$@" )
   file=${array[${#array[@]} - 1]}
   if [ ! -e "$file" ]; then echo "CANT FIND: $file" && return 1; fi
   savestate old "$file"
   tmp="$TMP/$(basename "$file")"
   unset "array[${#array[@]}-1]"
   cat "$file" > "$tmp"
   if [ -n "$d" ]; then
      huh=$(cat "$file")
      backdir="$file"
      if [ -z "$p" ]; then
         extract=$(string complete_extract "$d" "$d2" "$huh")
      else
         extract=$(string -r -p "$p" complete_extract "$d" "$d2" "$huh")
      fi
      file="$tmp"
      if [ -n "$extract" ]; then echo "$extract" > "$tmp"; else echo "CANT GET CONTENT: $d $d2" && return 1; fi
   fi
   for prop in "${array[@]}"; do
         limit=$(($limit + 1))
         newprop=
         propc=
         xml=
         space=
         space2=
         newspace=
         test "${prop#*=}" != "$prop" && propc=1
         test "${prop#*/>}" != "$prop" && xml=1
         test "${prop#*</}" != "$prop" && xml=1
         if [[ -n "$xml" && -n "$propc" ]]; then propc=0; fi
         if [[ "$xml" == "1" ]]; then
             newprop=$(string inside_symbol '="' '"' "$prop")
             newprop2=$(string inside_symbol ' ' ='"'$newprop'"' "$prop") 
             if [ -n "$newprop" ]; then
               if [[ $(grep -o "$newprop2" "$file" | wc -l) == "1"  ]]; then
                  newprop="$newprop2"
               elif ! is_substring "$newprop2" "$(grep -m1 "$newprop" "$file")"; then
                  newprop=
               fi
             fi
             if [[ -z "$newprop" || "$newprop" == "$prop" ]]; then
                if is_substring '</' "$prop"; then
                   newprop=$(echo "$prop" | sed -e 's/.*<\/\(.*\)>.*/\1/') 
                elif is_substring '/>' "$prop"; then
                   newprop=$(echo "$prop" | sed -e 's/.*<\(.*\)\/>.*/\1/')
                fi
             fi
             if [[ -n "$newprop" && "$newprop" != "$prop" ]]; then
                space=$(grep -m1 "$newprop" "$file" | cut -d'<' -f1)
                space2=$(echo "$prop" | cut -d'<' -f1)
                if [[ "$space" != "$space2" && -z "$nospace" ]]; then
                   newspace="$space"
                fi
             else
                newprop=
                echo2 " WARNING: Abnormal xml $prop"
             fi
         fi   
         if [[ "$propc" == "1" ]]; then  
             newprop=$(echo "$prop" | cut -d '=' -f1 | tr -d " ")
         fi  
         if [ -z "$newprop" ]; then continue; fi
         if [[ "$xml" == "1" && "$limit" == "1" ]]; then
             sed -i '/^$/d' "$tmp"
             last=$(tail -n 1 "$tmp")
             sed -i '$d' "$tmp"
         fi   
         echo2 "::$newprop"
         result=$(awk "!/$(string escape "$newprop")/" "$tmp")
         if [ ! -z "$result" ]; then echo "$result" > "$tmp"; fi
         echo "${newspace}${prop}" >> "$tmp"
   done
   if [[ "$xml" == "1" ]]; then
       echo "$last" >> "$tmp"
   fi
   result=$(cat "$tmp")
   if [ -n "$d" ]; then
      file="$backdir"
      echo "${huh/$extract/$result}" > "$tmp"
   fi
   if ! is_valid "$tmp"; then echo2 " FATAL ERROR: Invalid $tmp " && return 1; fi
   inject "$tmp" "$(dirname "$file")"
   rm -f "$tmp"
   savestate new "$file"
   if [[ "$old" != "$new" ]]; then true; else false; fi
}

force_update_file_addon() {
   local restore flag save save2 save3
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift 3
       ;;
       -no-spaces|-ns)
       save2=("$1")
       shift
       ;;
       -p|-pattern)
       save3=("$1" "$2")
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   force_update_file "${save[@]}" "${save2[@]}" "${save3[@]}" "$addons/$1" "$2"
}

force_update_file_zip() {
   local restore flag save result save2 save3
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -delim|-d)
       save=("$1" "$2" "$3")
       shift 3
       ;;
       -no-spaces|-ns)
       save2=("$1")
       shift
       ;;
       -p|-pattern)
       save3=("$1" "$2")
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   package_extract_file "$1" "$TMP/$(basename "$1")"
   force_update_file "${save[@]}" "${save2[@]}" "${save3[@]}" "$TMP/$(basename "$1")" "$2"
   result=$?
   rm -f "$TMP/$(basename "$1")"
   return $result
}

flash() {
	unzip -p -o "$2" "META-INF/com/google/android/update-binary" > "$TMP/update-binary-test"
    chmod +x "$TMP/update-binary-test"
    setdefault "$1" "$("$TMP/update-binary-test" 3 3 "$2" 2>&1)"
}

flash_addon() {
   flash "$1" "$addons/$2"
}

flash_zip() {
    package_extract_file "$2" "$TMP/$(basename "$2")"
    flash "$1" "$TMP/$(basename "$2")"
    rm -f "$TMP/$(basename "$2")"
}

add_lines() { 
    local old new restore flag al al_add bl bl_add file tmp array lines i TMP2
    restore=()
    while [[ $# -gt 0 ]]; do
    flag="$1"
    case $flag in
       -al|-after-line)
       al+=("$2")
       al_add+=("$3")
       shift 3
       ;;
       -bl|-before-line)
       bl+=("$2")
       bl_add+=("$3")
       shift 3
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
    esac
    done
    set -- "${restore[@]}"
    array=( "$@" )
    file=${array[${#array[@]} - 1]}
    unset "array[${#array[@]}-1]"
    start_tmp 
    tmp="$TMP2/$(basename "$file")"
    cat "$file" > "$tmp"
    for lines in "${array[@]}"; do
       cat "$lines" >> "$tmp"
    done
    for i in "${!al[@]}"; do
       add_lines_string -al "${al[i]}" "$(cat "${al_add[i]}")" "$tmp"
    done
    for i in "${!bl[@]}"; do
       add_lines_string -bl "${bl[i]}" "$(cat "${bl_add[i]}")" "$tmp"
    done
    savestate old "$file"
    if ! is_valid "$tmp"; then echo2 " FATAL ERROR: Invalid $tmp" && return 1; fi
    inject "$tmp" "$(dirname "$file")"
    end_tmp
    savestate new "$file"
    if [[ "$old" != "$new" ]]; then true; else false; fi
}

add_lines_string() {
    local vars file array lines restore flag get try
    local al al_add bl bl_add i old new
    restore=()
    while [[ $# -gt 0 ]]; do
    flag="$1"
    case $flag in
       -al|-after-line)
       al+=("$2")
       al_add+=("$3")
       shift 3
       ;;
       -bl|-before-line)
       bl+=("$2")
       bl_add+=("$3")
       shift 3
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
    esac
    done
    set -- "${restore[@]}"
    array=( "$@" )
    file=${array[${#array[@]} - 1]}
    savestate old "$file"
    unset "array[${#array[@]}-1]"
	cat "$file" > "$TMP/$(basename "$file")"
	for lines in "${array[@]}"; do
	   echo "$lines" >> "$TMP/$(basename "$file")"
	done
    if [ -n "$al" ]; then
       for i in "${!al[@]}"; do
          try=$(string -f "$TMP/$(basename "$file")" -after-line "${al[i]}" "${al_add[i]}")
          [ -n "$try" ] && echo "$try" > "$TMP/$(basename "$file")"
       done
    fi
    if [ -n "$bl" ]; then
       for i in "${!bl[@]}"; do
          try=$(string -f "$TMP/$(basename "$file")" -before-line "${bl[i]}" "${bl_add[i]}")
          [ -n "$try" ] && echo "$try" > "$TMP/$(basename "$file")"
       done
    fi
    if ! is_valid "$TMP/$(basename "$file")"; then echo2 " FATAL ERROR: Invalid $TMP/$(basename "$file") " && return 1; fi
    inject "$TMP/$(basename "$file")" "$(dirname "$file")"
    rm -f "$TMP/$(basename "$file")"
    savestate new "$file"
    if [[ "$old" != "$new" ]]; then true; else false; fi
}

add_lines_addon() {
    add_lines "$addons/$1" "$2"
}

add_lines_zip() {
    local result
    package_extract_file "$1" "$TMP/$(basename "$1")"
    add_lines "$TMP/$(basename "$1")" "$2"
    result=$?
    rm -f "$TMP/$(basename "$1")"
    return $result
}

setup_bb() {
   #Ensure /system/bin/sh
   if [ ! -f /system/bin/sh ]; then
      umount -l /system 2>/dev/null
      mkdir -p /system/bin
      ln -sf "$(command -v sh)" /system/bin/sh
   fi
   if [ -e "$bb" ]; then
     if ! "$bb" --install -s "$l"; then
        for i in $("$bb" --list); do
          if ! ln -sf "$bb" "$l/$i" && ! "$bb" ln -sf "$bb" "$l/$i" && ! "$bb" ln -f "$bb" "$l/$i"; then
            # create script wrapper if symlinking and hardlinking failed because of restrictive selinux policy
            if ! echo "#!$bb" > "$l/$i" || ! chmod 755 "$l/$i"; then
              abort "ERROR:1: Failed to setup busybox"
            fi
          fi
        done
     fi
   else
      abort "ERROR:2: Cant find busybox"
   fi
   if [ ! -f "$l/sh" ]; then abort "ERROR:3: Failed to setup busybox"; fi
}

set_context() {
   local context huh check="$1" check2="$2" contextback path dir ext try backdir
   if exist "$1"; then context=$(eval_context "$1"); else echo2 "set_context: Invalid line" && return 1; fi
   if defined context; then contextback="$context"; else echo2 "set_context: FATAL ERROR: Cant get context from $1" && return 1; fi
   if ! exist file "$2" || exist folder "$2"; then 
      find "$2" \( -type f -o -type d -o -type l \) | while read huh; do
         dir=
         try=
         ext=
         undefined huh && break
         context="$contextback"
         if exist folder "$1" && exist "$1$(string remove "$2" "$huh")"; then
            context=$(eval_context "$1$(string remove "$2" "$huh")")
         else
            while read -r -d/ path || [ -n "$path" ]; do
              if defined path; then
                dir+="/$path"
                if exist folder "$dir"; then
                  context=$(eval_context "$dir")
                  backdir="$dir"
                fi
              fi
            done <<< $(dirname "$1$(string remove "$2" "$huh")")
            ext=${huh##*.}
            if exist file "$huh"; then
               if defined ext; then try=$(find "$backdir" -mindepth 1 -type f -name "*.$ext" | head -n1); fi
               if exist "$try"; then context=$(eval_context "$try"); fi
            fi
         fi
         if undefined context; then context="$contextback"; fi
         echo2 "set_context: $context in $huh"
         chcon -h "$context" "$huh" || chcon "$context" "$huh"
      done
   elif exist file "$2"; then
      echo2 "set_context: $context in $2"
      chcon -h "$context" "$2" || chcon "$context" "$2"
   else
      echo2 "set_context: Invalid line"
   fi
}

eval_context() { ls -Z "$1" | cut -d' ' -f1 | sort | uniq -c | sort -rn | head -n1 | awk '{print $2}'; }

patch_fstab() {
   #patch_fstab userdata "fileencryption" "encryptable" "FILE"
   local huh line fstab count=0 back stock new
   if exist "$4"; then savestate stock "$4"; else echo2 "patch_fstab: Cant find $4" && return 1; fi
   fstab=$(grep -m1 "$1" "$4")
   if undefined fstab; then echo2 "patch_fstab: Cant get $1 line in $4" && return 1; fi
   back="$fstab"
   huh=$(split_string ',' "$fstab" | grep -m1 "$2")
   fstab=$(string replace "$huh" "$3" "$fstab")
   if defined back fstab huh && [[ "$fstab" != "$back" ]]; then
      echo2 "patch_fstab: $huh to $3"
      replace "$back" "$fstab" "$4"
      savestate new "$4"
      if [[ "$stock" != "$new" ]]; then echo2 "patch_fstab: Patched $4" && return 0; else return 1; fi
   else
      echo2 "patch_fstab: Abnormal fstab $4" && return 1
   fi
}

import_config() {
    local ugu propc
    while IFS='' read -r ugu || [[ -n "$ugu" ]]; do
          propc=
          test "${ugu#*=}" != "$ugu" && propc=1
          if [[ "$propc" == "1" ]]; then 
              setdefault "$(split_extract = 1 "$ugu" | tr -d ' ')" "$(split_extract = 2 "$ugu")"
          fi   
    done < "$1"
}

import_config_addon() {
    import_config "$addons/$1"
}

import_config_zip() {
    package_extract_file "$1" "$TMP/$(basename "$1")"
    import_config "$TMP/$(basename "$1")"
    rm -f "$TMP/$(basename "$1")"
}

getdefault() {
  grep -m1 "^setdefault $2" "$1" | tr -d '"' | sed s/"setdefault $2 "//
}

savestate() {
    setdefault "$1" "$(md5sum "$2" | awk '{ print $1; }')"
}

startlog() {
    setdefault logpath "$1"
    echo > "$1"
    if exist "$1"; then return 0; else return 1; fi
}

endlog() { unset logpath; }

savelog() {
    if [ -n "$logpath" ]; then
      echo "$1${n}" >> "$logpath"
    fi
    return 0
}

echolog() {
    if [ -n "$logpath" ]; then
      echo "$1${n}" >> "$logpath"
      echo2 "$1"
    fi
    return 0
}

printlog() {
    if [ -n "$logpath" ]; then
      echo "$1${n}" >> "$logpath"
      ui_print "$1"
    fi
    return 0
}

symlink() {
  local file="$1";
  while [ "$2" ]; do
    ln -sf "$file" "$2";
    shift;
  done;
}

ch_con_recursive() {
    local dcon fcon file folder s
    local restore flag f d
    restore=()
    while [[ $# -gt 0 ]]; do
    flag="$1"
    case $flag in
       -f|-file)
       f=true
       shift
       ;;
       -d|-dir)
       d=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
    esac
    done
    set -- "${restore[@]}"
    if defined d; then is_substring u:object "$1" && dcon=$1 || dcon=u:object_r:$1:s0; s=$(( $s + 1 )); fi
    if defined f; then is_substring u:object "$1" && fcon=$1 || fcon=u:object_r:$1:s0; s=$(( $s + 1 )); fi
    if undefined f d; then
       is_substring u:object "$1" && dcon=$1 || dcon=u:object_r:$1:s0; s=$(( $s + 1 ))
       is_substring u:object "$2" && fcon=$2 || fcon=u:object_r:$2:s0; s=$(( $s + 1 ))
    fi
    [[ $s == 0 ]] && return 1
    shift $s
    while [ "$1" ]; do
      [ -n "$dcon" ] && ( find "$1" -type d | while read folder; do echo2 "set_context: $dcon in $folder"; chcon -h $dcon "$folder" || chcon $dcon "$folder"; done)
      [ -n "$fcon" ] && ( find "$1" -type f -o -type l | while read file; do echo2 "set_context: $fcon in $file"; chcon -h $fcon "$file" || chcon $fcon "$file"; done)
      shift;
    done;
}

restore_con() {
  restorecon -R "$@";
}

set_perm_recursive() {
  local uid gid dmod fmod;
  uid=$1; gid=$2; dmod=$3; fmod=$4;
  shift 4;
  while [ "$1" ]; do
    chown -R $uid:$gid "$1" || chown -R $uid.$gid "$1";
    find "$1" -type d -exec chmod $dmod {} +;
    find "$1" -type f -exec chmod $fmod {} +;
    shift;
  done;
}

set_perm_recursive2() {
  #Ensure this perm format
  local uid gid dmod fmod;
  uid=$1; gid=$2; dmod=$3; fmod=$4;
  shift 4;
  while [ "$1" ]; do
    chown -R $uid:$gid "$1" || chown -R $uid.$gid "$1";
    find "$1" -type d -exec chmod $dmod {} +;
    find "$1" -type f -exec chmod $fmod {} +;
    shift;
  done;
}

backup_files() {
  while [ "$1" ]; do
    test ! -e "$1.bak" && cp -pf "$1" "$1.bak";
    shift;
  done;
}

restore_files() {
  while [ "$1" ]; do
    mv -f "${1}.bak" "$1";
    shift;
  done;
}

sha3_check() {
  local sum=$(sha3sum $1 | cut -c-40);
  if [ ! "$2" -o $(is_substring $sum "$*") == 1 ]; then
    echo $sum;
  fi;
}

assert() {
  while [ "$1" ]; do
    $1;
    test $? != 0 && abort 'assert failed('"$1"')';
    shift;
  done;
}

split_string() {
    local split delim
    local IFS=$'\n'
    split="$2"
    split=${split//"$1"/$'\n'}
    for delim in $split; do
        echo "$delim"
    done
}

split_cut() {
    local split count delim
    local IFS=$'\n'
    split="$3"
    split=${split//"$1"/$'\n'}
    count=0
    for delim in $split; do
        count=$(($count + 1))
        echo "$delim"
        if [[ "$count" == "$2" ]]; then return; fi;
    done
}

split_extract() {
    local split count delim
    local IFS=$'\n'
    split="$3"
    split=${split//"$1"/$'\n'}
    count=0
    for delim in $split; do
        count=$(($count + 1))
        if [[ "$count" == "$2" ]]; then echo "$delim" && return; fi;
    done
}

checkvar() {
    local splittt13yu
    for splittt13yu in "$@"; do
      eval splittt13yu="\${${splittt13yu}}" 
	  if [ -n "$splittt13yu" ]; then echo "$splittt13yu"; fi;
	done
}

filtervar() {
    local splittt13yu filter717w8jw array61716opr
    array61716opr=( "$@" )
    filter717w8jw=${array61716opr[${#array61716opr[@]} - 1]}
    unset "array61716opr[${#array61716opr[@]}-1]"
    for splittt13yu in "${array61716opr[@]}"; do
		eval splittt13yu="\${${splittt13yu}}" 
        if [ -n "$splittt13yu" ]; then
           if is_substring "$filter717w8jw" "$splittt13yu"; then echo "$splittt13yu"; fi;
    	fi
    done
}

import_bin() {
    cp -pf "$1" "$l"
    if ! chmod +x "$l/$(basename "$1")"; then echo2 " Cant import: $1" && return 1; fi
}

import_bin_addon() {
   import_bin "$addons/$1"
}

import_bin_zip() {
   local result
   package_extract_file "$1" "$TMP/$(basename "$1")"
   import_bin "$TMP/$(basename "$1")"
   result=$?
   rm -f "$TMP/$(basename "$1")"
   return $result
}

setdefault() {
    read -r -d '' "$1" <<< "$2"
    defined "$1" && return 0 || return 1
}

is_number() { echo "$1" | grep -E "^[0-9]+$" > /dev/null && return 0 || return 1; }

is64bit() { local byte=$(od -An -t x1 -j 4 -N 1 "$1" | tr -d " "); if [[ "$byte" == "02" ]]; then return 0; elif [[ "$byte" == "01" ]]; then return 1; else echo Unknown && return 1; fi }

binarch() { local byte=$(od -An -t x1 -j 4 -N 1 "$1" | tr -d " "); if [[ "$byte" == "02" ]]; then echo 64bits; elif [[ "$byte" == "01" ]]; then echo 32bits; else echo Unknown && return 1; fi }

can_run() {
   local check
   check=$($1 --help 2>&1)
   if [[ -f "$1" && -x "$1" && "$check" != *"CANNOT LINK"* ]]; then return 0
   elif [ -f "$(command -v "$1")" ]; then
      check=$($(command -v "$1") --help 2>&1)
      if [[ -x "$(command -v "$1")" && "$check" != *"CANNOT LINK"* ]]; then return 0; else return 1; fi
   else return 1
   fi
}

make_overlay() {
   #make_overlay 1 com.android FOLDER result.apk
   local package content result tmp current random priority TMP2
   priority="$1"
   package="$2"
   content="$3"
   result="$4"
   start_tmp
   tmp="$TMP2/overlay"
   echo ">>Overlay Maker 1.0.0"
   if [[ -z "$package" || -z "$content" || -z "$result" || -z "$priority" || ! -d "$content" ]]; then echo " make_overlay: Invalid line " && return; fi
   echo " L: Detected $package..."
   echo " L: With $content..."
   echo " L: Building $(basename "$result")..."
   random=$(echo "$RANDOM" | tr '[0-9]' '[a-z]')
   dynamic_apktool -d "$l/overlay.apk" -o "$tmp" >/dev/null
   if ! exist "$tmp/AndroidManifest.xml"; then echo " CANT setup: make_overlay " && return 1; fi
   replace "overlay.template" "com.$random.dynamic.installer" "$tmp/AndroidManifest.xml"
   replace 'android:targetPackage="android"' 'android:targetPackage="'$package'"' "$tmp/AndroidManifest.xml"
   replace 'android:priority="1"' 'android:priority="'$priority'"' "$tmp/AndroidManifest.xml"
   delete_recursive "$tmp/res"
   current=${PWD}
   cd "$content"
   cp -prf * "$tmp"
   cd "$current"
   dynamic_apktool -sign -r "$tmp" -o "$result" >/dev/null
   if exist "$result"; then echo " L: Success $(basename "$result")"; else echo " make_overlay: Cant compile $(basename "$result")" && return 1; fi
   end_tmp
}

make_overlay_addon() {
   make_overlay "$1" "$2" "$addons/$3" "$4"
}

make_overlay_zip() {
    local result
    delete_recursive "$TMP/00patch"
    package_extract_dir "$3" "$TMP/00patch"
    make_overlay "$1" "$2" "$TMP/00patch" "$4"
    result=$?
    delete_recursive "$TMP/00patch"
    return $result
}

make_zip() {
   local make="$TMP/NewZIP" current=${PWD}
   local restore flag script include include2 type pa output i base head
   local recovery="$make/META-INF/com/google/android"
   local magisk="$make/META-INF/com/google/android/magisk"
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -script|-s)
       script="$2"
       shift 2
       ;;
       -preserve-addons|-pa)
       pa=true
       shift
       ;;
       -type|-t)
       type="$2"
       shift 2
       ;;
       -output|-o)
       output="$2"
       shift 2
       ;;
       -include|-i)
       include+=("$2")
       shift 2
       ;;
       -magisk-include|-mi)
       include2+=("$2")
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   for base in script type output; do
     if undefined $base; then echo2 "make_zip: Invalid line" && return 1; fi
   done
   echo2 '>>> Make ZIP 1.0.0'
   echo2 "-- Making space..."
   delete_recursive "$make"
   package_extract_dir META-INF "$make/META-INF"
   if undefined pa; then delete_recursive "$make/META-INF/addons"; fi
   mkdir -p "$make/META-INF/addons" 2>/dev/null
   for i in "${!include[@]}"; do
      if exist "${include[i]}"; then 
        echo2 "Adding: ${include[i]}"
        cp -pfr "${include[i]}" "$make"
      fi
   done
   for i in "${!include2[@]}"; do
      if exist "${include2[i]}"; then 
        echo2 "Adding:magisk: ${include2[i]}"
        cp -pfr "${include2[i]}" "$magisk"
      fi
   done
   echo2 "-- Making scripts..."
   if is_equal "$type" "recovery"; then
      delete "$recovery/updater-script" 
      if ! is_substring "#MAGISK" "$script"; then echo "#MAGISK" > "$recovery/updater-script"; fi
      echo "$script" >> "$recovery/updater-script" 
   elif is_equal "$type" "magisk"; then
      head=$(string complete_extract 'Dynamic Installer Configs' '#-----------------------' -f "$recovery/updater-script")
      if [ -n "$head" ] && is_substring setdefault "$head"; then echo "$head" > "$recovery/updater-script"; else echo2 "Cant get: Dynamic Installer Configs: updater-script" && return 1; fi
      if ! is_substring "#MAGISK" "$(cat "$recovery/updater-script")"; then echo "#MAGISK" >> "$recovery/updater-script"; fi
      echo "$script" > "$magisk/customize.sh" 
   else
      echo2 "FATAL ERROR: Invalid type" && return 1
   fi
   echo2 "-- Making ZIP..."
   if ! exist "$(dirname "$output")"; then mkdir -p "$(dirname "$output")"; fi
   ( cd "$make" && zip -r "$output" * ) > /dev/null
   cd "$current"
   delete_recursive "$make"
   if is_valid "$output"; then echo2 "-- Done" && return 0; else echo2 "-- ERROR" && return 1; fi
}

dynamic_install_apk() {
   local userlist package f try inst_dir package2 
   local temp_dir temp_dest temp_pack check_split check_package restore flag out nr na
   local ro ra include i file check_overlay
   if ! aapt version >/dev/null; then echo " CANT LOAD AAPT: U cant use dynamic_install_apk " && return 1; fi
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -o|-output)
       out="$2"
       shift 2
       ;;
       -nr|-no-replace)
       nr=true
       shift
       ;;
       -na|-no-add)
       na=true
       shift
       ;;
       -ro|-remove-oat)
       ro=true
       shift
       ;;
       -i|-include)
       include+=("$2")
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   delete "$TMP/userlist.txt"
   delete "$TMP/packages.txt"
   while read userlist; do
       if undefined userlist; then echo2 "dynamic_install_apk: Cant find any apk in $2 " && break; fi
       check_overlay=
       package=
       package=$(apk_package "$userlist")
       check_overlay=$(aapt dump xmlstrings "$userlist" AndroidManifest.xml | grep -w " overlay")
       if undefined check_overlay; then
          echo "$userlist" >> "$TMP/userlist.txt"
          echo "$(basename "$userlist")=$package" >> "$TMP/packages.txt"
       fi
   done <<< $(find "$2" -type f -name "*.apk" 2>/dev/null)
   if ! exist "$TMP/packages.txt" "$TMP/userlist.txt"; then
     #Make false files
     echo > "$TMP/packages.txt" 
     echo > "$TMP/userlist.txt"
   fi
   while read f; do
     if undefined f; then echo2 "dynamic_install_apk: Cant find any apk in $1 " && break; fi
     check_split=
     check_package=
     check_split=$(aapt dump badging "$f" | sed -n "s/.* split='\([^']*\).*$/\1/p")
     if [[ -n "$temp_pack" && -n "$temp_dir" && "$temp_dir" == "$(dirname "$f")" ]]; then
        check_package=$(apk_package "$f")
        if [[ -n "$check_split" && "$check_package" == "$temp_pack" ]]; then
           echo2 "add:split: $(basename "$f") in $temp_dest"
           inject "$f" "$temp_dest" && continue
        fi
     fi
     try=
     inst_dir=$(dirname "$f")
     inst_dir=${inst_dir#$1}
     package=$(apk_package "$f")
     try=$(grep -m1 "$package" "$TMP/packages.txt" | cut -d '=' -f1)
     package2=$(get_file_prop "$TMP/packages.txt" "$try")
     if [[ "$package" == "$package2" ]]; then try=$(grep -m1 "$try" "$TMP/userlist.txt"); fi;
     if [[ -n "$try" && -f "$try" && -z "$check_split" ]]; then
        if [ -n "$nr" ]; then continue; fi
        if [ -n "$out" ]; then try="$out$try"; fi
        temp_pack="$package"
        temp_dir=$(dirname "$f")
        temp_dest=$(dirname "$try")
        if [ -n "$ro" ]; then rm -rf "$temp_dest/oat" 2>/dev/null; fi
        if ! exist "$temp_dest"; then mkdir -p "$temp_dest"; fi
        echo2 "replace: $package in $try"
        cp -pf "$f" "$try"
        if [ -d "$temp_dir/lib" ]; then cp -pfr "$temp_dir/lib" "$temp_dest"; fi
        for i in "${!include[@]}"; do
          if exist "$temp_dir/${include[i]}"; then 
             echo2 "add:extra: ${include[i]}"
             cp -pfr "$temp_dir/${include[i]}" "$temp_dest"
          fi
        done
        set_perm_recursive2 0 0 0755 0644 "$temp_dest"
     elif [ -z "$check_split" ]; then
        if [ -n "$na" ]; then continue; fi
        temp_pack="$package"
        temp_dir=$(dirname "$f")
        temp_dest="$2${inst_dir}"
        if [ -n "$out" ]; then temp_dest="$out$temp_dest"; fi
        if [ -n "$ro" ]; then rm -rf "$temp_dest/oat" 2>/dev/null; fi
        echo2 "add: $package in $temp_dest"
        inject "$f" "$temp_dest"
        if [ -d "$temp_dir/lib" ]; then cp -pfr "$temp_dir/lib" "$temp_dest"; fi
        for i in "${!include[@]}"; do
          if exist "$temp_dir/${include[i]}"; then 
             echo2 "add:extra: ${include[i]}"
             cp -pfr "$temp_dir/${include[i]}" "$temp_dest"
          fi
        done
        set_perm_recursive2 0 0 0755 0644 "$temp_dest"
     fi
   done <<< $(find "$1" -mindepth 1 -type f -name "*.apk")
}

hex_patch() {
    local xxd 
    if xxd --help >/dev/null; then
       xxd=xxd
    elif /system/bin/xxd --help >/dev/null; then 
       xxd="/system/bin/xxd"
    elif /system/bin/toybox xxd --help >/dev/null; then 
       xxd="/system/bin/toybox xxd"
    elif [ ! -e "/data/adb/magisk/magiskboot" ]; then
       echo "CANT LOAD: xxd or magiskboot" && return 1
    fi
    if ! exist "$3"; then echo "CANT FIND: $3" && return 1; fi
    if $($xxd -p "$3" | tr -d \\n | tr -d " " | sed "s/$1/$2/" | $xxd -r -p > "$3.tmp"); then
      if hex_check "$2" "$3.tmp"; then
         mv -f "$3.tmp" "$3"
         true
      elif [ -e "/data/adb/magisk/magiskboot" ]; then
         if $(/data/adb/magisk/magiskboot hexpatch "$3" "$1" "$2"); then
           if hex_check "$2" "$3"; then true; else false; fi
         else
           false
         fi   
      else
         false
      fi
    elif [ -e "/data/adb/magisk/magiskboot" ]; then
        if $(/data/adb/magisk/magiskboot hexpatch "$3" "$1" "$2"); then
           if hex_check "$2" "$3"; then true; else false; fi
        else
           false
        fi 
    else
       false  
    fi
}

hex_search() {
    local xxd restore flag
    local after before
    if xxd --help >/dev/null; then
       xxd=xxd
    elif /system/bin/xxd --help >/dev/null; then 
       xxd="/system/bin/xxd"
    elif /system/bin/toybox xxd --help >/dev/null; then 
       xxd="/system/bin/toybox xxd"
    else
       echo " CANT LOAD XXD bin" && return
    fi
    restore=()
    while [[ $# -gt 0 ]]; do
    flag="$1"
    case $flag in
        -include)
        after=$(echo "$2" | grep -Eio "after:[0-9]+" | cut -f2 -d:)
        before=$(echo "$2" | grep -Eio "before:[0-9]+" | cut -f2 -d:)
        if [[ -z "$after" && -z "$before" ]]; then ui_print "hex_search: invalid line" && return; fi
        shift 2
        ;;
        *)   
        restore+=("$1")
        shift
        ;;
    esac
    done
    set -- "${restore[@]}"
    if ! exist "$2"; then echo "CANT FIND: $2" && return 1; fi
    if [ -z "$after" ]; then after=0; fi
    if [ -z "$before" ]; then before=0; fi
    $xxd -p "$2" | tr -d \\n | tr -d " " | grep -E -o ".{0,${before}}$1.{0,${after}}"
}

hex_check() {
    local xxd
    if xxd --help >/dev/null; then
       xxd=xxd
    elif /system/bin/xxd --help >/dev/null; then 
       xxd="/system/bin/xxd"
    elif /system/bin/toybox xxd --help >/dev/null; then 
       xxd="/system/bin/toybox xxd"
    else
       echo " CANT LOAD XXD bin" && return
    fi
    if ! exist "$2"; then echo "CANT FIND: $2" && return 1; fi
    if $($xxd -p "$2" | tr -d \\n | tr -d " " | grep "$1" >/dev/null); then true; else false; fi
}

getvalue() {
   local try
   try=$1
   shift 1
   TEMP=`getopt --long -o "$try:" "$@"`
   eval set -- "$TEMP"
   while true ; do
       case "$1" in
           -$try )
               echo "$2"
               shift 2
           ;;
           *)
               break
           ;;
       esac 
   done
}

get_equal_value() {
   local equal i
   equal="$1"
   shift 1
   for i in "$@"
   do
   case $i in
       $equal=*)
       echo "${i#*=}"
       shift
       ;;
       *)
       ;;
   esac
   done
}

get_custom_value() {
   local value key
   value="$1"
   shift 1
   while [[ $# -gt 0 ]]
   do
   key="$1"
   case $key in
       $value)
       echo "$2"
       shift 2
       ;;
       *)  
       shift
       ;;
   esac
   done
}

start_tmp(){
   local random
   random=$(echo "$RANDOM" | tr '[0-9]' '[a-z]')
   TMP2="$TMP/$random"
   kskwiiuwu+=("$TMP2")
   delete_recursive "$TMP2"
   mkdir -p "$TMP2"
}

end_tmp() {
   local i refresh
   delete_recursive "${kskwiiuwu[${#kskwiiuwu[@]} - 1]}"
   unset "kskwiiuwu[${#kskwiiuwu[@]}-1]"
   for i in "${!kskwiiuwu[@]}"; do
      refresh+=("${kskwiiuwu[i]}")
   done
   kskwiiuwu=("${refresh[@]}")
   TMP2=
}

replace() {
   local restore flag r a file try rpl old new load
   local result=1
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -r|-recursive)
       r=true
       shift
       ;;
       -a|-all-line)
       a=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   file="$3"
   if ! exist "$file"; then echo "CANT FIND: $file" && return 1; fi
   try="$1"
   rpl="$2"
   if [ -n "$r" ]; then
       while read huh; do
           undefined huh && break
           dir=$(echo "$huh" | cut -f1 -d:)
           savestate old "$dir"
           if [ -n "$a" ]; then
               sed -i "/$(string escape "$try")/s/.*/$(string escape "$rpl")/" "$dir"
           else
               load=$(cat "$dir")
               echo "${load//"$try"/"$rpl"}" > "$dir"
           fi
           savestate new "$dir"
       done <<< $(grep -rn "$file" -e "$try")
   else
       savestate old "$file"
       if [ -n "$a" ]; then
           sed -i "/$(string escape "$try")/s/.*/$(string escape "$rpl")/" "$file"
       else
           load=$(cat "$file")
           echo "${load//"$try"/"$rpl"}" > "$file"
       fi
       savestate new "$file"
   fi
   if [[ "$old" != "$new" ]]; then return 0; else return 1; fi
}

getsize() {
   stat -c%s "$1"
}

string() {
   #Multi-tool for Strings by @BlassGO
   local restore flag string array result
   local replace rpl rpl2 rpll rpll2 rm ca c i try try2 huh upper lower et et2 ex ex2 exn exn2 escape
   local al al_add bl bl_add get
   local p1 p2 r p file back return=0
   local ga gb
   local fix='s/[]\/$*.^[]/\\&/g'
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       replace)
       rpl+=("$2")
       rpl2+=("$3")
       shift 3
       ;;
       replace_line)
       rpll+=("$2")
       rpll2+=("$3")
       shift 3
       ;;
       remove)
       rm+=("$2")
       shift 2
       ;;
       inside_symbol)
       et="$2"
       et2="$3"
       shift 3
       ;;
       inside)
       p1="$2"
       p2="$3"
       shift 3
       ;;
       extract)
       ex="$2"
       ex2="$3"
       shift 3
       ;;
       complete_extract)
       exn="$2"
       exn2="$3"
       shift 3
       ;;
       upper)
       upper=true
       shift
       ;;
       escape)
       escape=true
       shift
       ;;
       lower)
       lower=true
       shift
       ;;
       count)
       c=true
       shift
       ;;
       -al|-after-line)
       al+=("$2")
       al_add+=("$3")
       shift 3
       ;;
       -bl|-before-line)
       bl+=("$2")
       bl_add+=("$3")
       shift 3
       ;;
       -ga|-get-after)
       ga="$2"
       shift 2
       ;;
       -gb|-get-before)
       gb="$2"
       shift 2
       ;;
       -r|-recursive)
       r=true
       shift
       ;;
       -p|-pattern)
       p="$2"
       shift 2
       ;;
       -f|-file)
       file="$2"
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   array=( "$@" )
   if [ -z "$file" ]; then
      string=${array[${#array[@]} - 1]}
      unset "array[${#array[@]}-1]"
   else
      if exist file "$file"; then string=$(cat "$file"); else echo2 "string: Cant find $file" && return 1; fi
   fi
   back="$string"
   for i in "${!rpl[@]}"; do
      if [ -n "$r" ]; then
         string="${string//"${rpl[i]}"/"${rpl2[i]}"}"
      else
         string="${string/"${rpl[i]}"/"${rpl2[i]}"}"
      fi
   done
   for i in "${!rpll[@]}"; do
      try=$(echo "${rpll[i]}" | sed -e $fix)
      huh=$(echo "${rpll2[i]}" | sed -e $fix)
      string=$(echo "$string" | sed -e "/$try/s/.*/$huh/")
   done
   for i in "${!rm[@]}"; do
      if [ -n "$r" ]; then
         string="${string//"${rm[i]}"/}"
      else
         string="${string/"${rm[i]}"/}"
      fi
   done
   if [ -n "$al" ]; then
       for i in "${!al[@]}"; do
          try=$(echo "${al[i]}" | sed -e $fix)
          if [ $(echo "${al_add[i]}" | wc -l) -gt 2 ]; then
             get=$(echo "${al_add[i]}" | sed ':a;N;$!ba;s/\n/\\n/g' | sed 's/\$/\\$/g')
          else
             get="${al_add[i]}"
          fi
          huh=$(echo "${al_add[i]}" | grep "." | head -n1)
          string=$(echo "$string" | sed -e '/'"$try"'/a\'"$get")
          if ! echo "$string" | grep -q "$huh"; then return 1; fi
       done
    fi
    if [ -n "$bl" ]; then
       for i in "${!bl[@]}"; do
          try=$(echo "${bl[i]}" | sed -e $fix)
          if [ $(echo "${bl_add[i]}" | wc -l) -gt 2 ]; then
             get=$(echo "${bl_add[i]}" | sed ':a;N;$!ba;s/\n/\\n/g' | sed 's/\$/\\$/g')
          else
             get="${bl_add[i]}"
          fi
          huh=$(echo "${bl_add[i]}" | grep "." | head -n1)
          string=$(echo "$string" | sed -e '/'"$try"'/i\'"$get")
          if ! echo "$string" | grep -q "$huh"; then return 1; fi
       done
    fi
   if [ -n "$et" ]; then
      try=$(echo "$string" | awk -F "$et|$et2" '{print $2}')
      if [ -n "$try" ]; then string="$try"; fi
   fi
   if [ -n "$p1" ]; then
      try=${string#*"$p1"}
      try=${try%"$p2"*}
      if [[ -n "$try" && $(echo "$try" | wc -l) == 1 ]]; then string="$try"; fi
   fi
   if [ -n "$ga" ]; then
      try=${string#*"$ga"}
      if [[ -n "$try" && $(echo "$try" | wc -l) == 1 ]]; then string="$try"; fi
   fi
   if [ -n "$gb" ]; then
      try=${string%"$gb"*}
      if [[ -n "$try" && $(echo "$try" | wc -l) == 1 ]]; then string="$try"; fi
   fi
   if [ -n "$ex" ]; then
      try=
      huh=
      try=$(echo "$ex" | sed -e $fix)
      huh=$(echo "$ex2" | sed -e $fix)
      if [ -z "$r" ]; then
         try=$(echo "$string" | sed -n "/$try/,/$huh/{p; /$huh/q}" | sed -e '1d;$d')
         if defined p && ! echo "$try" | grep -q "$p"; then try=; fi
      else
         #Recursive analysis
         if [ -z "$p" ]; then
            try=$(echo "$string" | sed -n "/$try/,/$huh/{ /$try/! { /$huh/! p } }")
         else
            try=$(echo "$string" | sed -n "/$try/,/$huh/p" | sed -e "/$try/s/.*/\n\n/" | sed -e "/$huh/s/.*/\n\n/" | awk -v RS='' "/$p/")
         fi
      fi
      if [ -n "$try" ]; then string="$try"; fi
   fi
   if [ -n "$exn" ]; then
      try=
      huh=
      try=$(echo "$exn" | sed -e $fix)
      huh=$(echo "$exn2" | sed -e $fix)
      if [ -z "$r" ]; then
         try=$(echo "$string" | sed -n "/$try/,/$huh/{p; /$huh/q}")
         if defined p && ! echo "$try" | grep -q "$p"; then try=; fi
      else
         #Recursive analysis
         if [ -z "$p" ]; then
            try=$(echo "$string" | sed -n "/$try/,/$huh/p")
         else
            try=$(echo "$string" | sed -n "/$try/,/$huh/p" | sed -e '/'"$try"'/i\'${n}${n} | sed -e '/'"$huh"'/a\'${n}${n} | awk -v RS='' "/$p/")
         fi
      fi
      if ! echo "$try" | head -n1 | grep -q "$exn"; then return 1; fi
      if ! echo "$try" | tail -n1 | grep -q "$exn2"; then return 1; fi
      if [ -n "$try" ]; then string="$try"; fi
   fi
   if [[ -n "$upper" && -z "$lower" ]]; then
      string=$(echo "$string" | tr '[:lower:]' '[:upper:]')
   elif [[ -z "$upper" && -n "$lower" ]]; then
      string=$(echo "$string" | tr '[:upper:]' '[:lower:]')
   fi
   if [ -n "$escape" ]; then
      string=$(echo "$string" | sed -e $fix)
   fi
   if [[ -z "$c" && -z "$escape" && -z "$upper" && -z "$lower" && -z "$exn" && "$string" == "$back" ]]; then return 1; fi
   if [ -n "$c" ]; then
      echo "${#string}"
   else
      echo "$string"
   fi
   return $return
}

chooseport() {
  # Keycheck binary by someone755 @Github
  local error=0
  while true; do
    sleep 1
    keycheck_$arch32
    local SEL=$?
    if [ $SEL -eq 42 ]; then
      return 0
    elif [ $SEL -eq 41 ]; then
      return 1
    else
      abort " ERROR: keycheck "
    fi
  done
}

find_block() {
   local BLOCK DEV DEVICE DEVNAME PARTNAME UEVENT
   local restore flag express time t=5
   restore=()
   while [[ $# -gt 0 ]]; do
     flag="$1"
     case $flag in
         -e|-express)
         express=true
         shift
         ;;
         -t|-time)
         time="$2"
         shift 2
         ;;
         *)   
         restore+=("$1")
         shift
         ;;
     esac
   done
   set -- "${restore[@]}"
   if [ -n "$time" ] && ! is_number "$time"; then echo2 "find_block: Invalid line" && return 1
   elif [ -n "$time" ] && is_number "$time"; then t="$time"
   fi
   for BLOCK in "$@"; do
     DEVICE=`timeout -t $t find /dev/block \( -type b -o -type c -o -type l \) -iname $BLOCK -o -iname $BLOCK$slot | head -n 1` 2>/dev/null
     if [ ! -z $DEVICE ]; then
       readlink -f $DEVICE
       return 0
     fi
   done
   if [ -z "$express" ]; then
      # Fallback by parsing sysfs uevents
      SECONDS=0
      for UEVENT in /sys/dev/block/*/uevent; do
        if [[ -n "$time" && "$time" -le "$SECONDS" ]]; then break; fi
        DEVNAME=`grep_prop DEVNAME $UEVENT`
        PARTNAME=`grep_prop PARTNAME $UEVENT`
        for BLOCK in "$@"; do
          if [[ "$(toupper $BLOCK)" == "$(toupper $PARTNAME)" || "$(toupper $BLOCK$slot)" == "$(toupper $PARTNAME)" ]]; then
            echo /dev/block/$DEVNAME
            return 0
          fi
        done
      done
   fi
   # Look just in /dev in case we're dealing with MTD/NAND without /dev/block devices/links
   for DEV in "$@"; do
     DEVICE=`timeout -t $t find /dev \( -type b -o -type c -o -type l \) -maxdepth 1 -iname $DEV -o -iname $DEV$slot | head -n 1` 2>/dev/null
     if [ ! -z $DEVICE ]; then
       readlink -f $DEVICE
       return 0
     fi
   done
   return 1
}

toupper() {
  echo "$@" | tr '[:lower:]' '[:upper:]'
}

grep_cmdline() {
  local REGEX="s/^$1=//p"
  cat /proc/cmdline | tr '[:space:]' '\n' | sed -n "$REGEX" 2>/dev/null
}

grep_prop() {
  local REGEX="s/^$1=//p"
  shift
  local FILES=$@
  [ -z "$FILES" ] && FILES='/system/build.prop'
  cat $FILES | dos2unix | sed -n "$REGEX" 2>/dev/null | head -n 1
}

try_mount() {
  local try basetry part result
  local restore flag rw ro re name file LOOP express
  restore=()
  while [[ $# -gt 0 ]]; do
  flag="$1"
  case $flag in
       -rw|-read-write)
       rw=true
       shift
       ;;
       -ro|-read-only)
       ro=true
       shift
       ;;
       -re|-remount)
       re=true
       shift
       ;;
       -e|-express)
       express=true
       shift
       ;;
       -n|-name)
       name="$2"
       shift 2
       ;;
       -f|-file)
       file="$2"
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
  done
  set -- "${restore[@]}"
  #Ensure root space
  mount -o rw,remount -t auto / 2>/dev/null
  if undefined ro rw; then rw=true && ro=true; fi
  for try in "$@"; do
     if [ -z "$name" ]; then basetry=$(split_extract / 1 "$try"); else basetry="$name"; fi
     if [[ -z "$file" && -z "$express" ]]; then part=$(find_block "$basetry")
     elif [[ -z "$file" && -n "$express" ]]; then part=$(find_block -e "$basetry")
     else
        basetry="No needed"
        if [ ! -f "$file" ]; then echo2 " CANT FIND: $file" && return 1; fi
        if can_run losetup2; then
           if [ -n "$name" ]; then
              start_loop "$name" "$file" 2>/dev/null
              part="$LOOP"
           else
              part=$(losetup2 -Pf --show "$file" 2>/dev/null)
           fi
           if [ -z "$part" ]; then echo2 " Cant loop: $file" && return 1
           elif losetup2 -a | grep -q "$part"; then
             echo2 " Looping: $part"
             contains_array "$try" "${all_looped[@]}" || all_looped+=("$try")
             contains_array "$part" "${all_looped_loop[@]}" || all_looped_loop+=("$part")
           else
             echo2 " Cant loop: $file" && return 1
           fi
        else
           echo2 "Unsupported: $(bin_info losetup2)" && return 1
        fi
     fi
     if [[ -n "$part" && -n "$basetry" ]]; then
         [ -n "$rw" ] && blockdev --setrw "$part" >/dev/null 2>&1
         setup_mountpoint "$try"
         if [ -n "$re" ]; then [[ -n "$name" && -d "/$name" ]] && unmount "/$name"; unmount "$try"; fi
         if ! is_mounted "$try" || [ -n "$file" ]; then
            if [ -n "$rw" ]; then
               if $(mount -w "$try" 2>/dev/null); then
                 echo2 " Mounting:1: $part $try" && result=0
               elif $(mount -w "$part" "$try" 2>/dev/null); then
                 echo2 " Mounting:2: $part $try" && result=0
               elif $(mount -w -t auto "$part" "$try" 2>/dev/null); then
                 echo2 " Mounting:3: $part $try" && result=0
               elif $(mount -w -t ext4 "$part" "$try" 2>/dev/null); then
                 echo2 " Mounting:4: $part $try" && result=0
               elif $(mount -o rw,remount -t auto "$try" 2>/dev/null); then
                 echo2 " Mounting:5: $part $try" && result=0
               elif $(mount -o rw,remount -t auto "$part" "$try" 2>/dev/null); then
                 echo2 " Mounting:6: $part $try" && result=0
               else
                 if ! is_mounted "$try"; then echo2 " CANT MOUNT: $try as RW" && result=1; fi
               fi
            fi
            if [ -n "$ro" ] && ! is_mounted "$try"; then
               if $(mount -r "$try" 2>/dev/null); then
                 echo2 " Mounting:ro:1: $part $try" && result=0
               elif $(mount -r "$part" "$try" 2>/dev/null); then
                 echo2 " Mounting:ro:2: $part $try" && result=0
               else
                 if ! is_mounted "$try"; then echo2 " CANT MOUNT: $try as RO" && result=1; fi;
               fi
            fi
         else
            if [ -n "$rw" ] && $(mount -o rw,remount -t auto "$try" 2>/dev/null); then
                echo2 " Mounting:auto:1: $part $try" && result=0
            elif [ -n "$rw" ] && $(mount -o rw,remount -t auto "$part" "$try" 2>/dev/null); then
                echo2 " Mounting:auto:2: $part $try" && result=0
            elif [ -n "$ro" ] && $(mount -o ro,remount -t auto "$try" 2>/dev/null); then
                echo2 " Mounting:auto:ro:1: $part $try" && result=0
            elif [ -n "$ro" ] && $(mount -o ro,remount -t auto "$part" "$try" 2>/dev/null); then
                echo2 " Mounting:auto:ro:2: $part $try" && result=0
            else
                echo2 " Already mounted: $try" && result=1
            fi
         fi
     else
        echo2 "Attempted with: $basetry $part"
        if [ -n "$re" ]; then [[ -n "$name" && -d "/$name" ]] && unmount "/$name"; unmount "$try"; fi
        if ! is_mounted "$try"; then
           setup_mountpoint "$try"
           if [ -n "$rw" ] && $(mount -w "$try" 2>/dev/null); then
              echo2 " Mounting:noblock:rw: $try" && result=0
           elif [ -n "$ro" ] && $(mount -r "$try" 2>/dev/null); then
              echo2 " Mounting:noblock:ro: $try" && result=0
           else
              if ! is_mounted "$try"; then echo2 " CANT MOUNT: $try" && result=1; fi;
           fi
        else
            if [ -n "$rw" ] && $(mount -o rw,remount -t auto "$try" 2>/dev/null); then
                echo2 " Mounting:auto:noblock:1: $try" && result=0
            elif [ -n "$ro" ] && $(mount -o ro,remount -t auto "$try" 2>/dev/null); then
                echo2 " Mounting:auto:noblock:ro:1: $try" && result=0
            else
                echo2 " Already mounted: $try" && result=1
            fi
        fi
     fi
     if is_mounted "$try"; then contains_array "$try" "${all_umount[@]}" || all_umount+=("$try"); else result=1; fi
  done
  return $result
}

run_wait() {
    local pid count time="$1"
    if ! is_number "$time"; then echo "run_wait: Invalid Line" && return 1; fi
    if exist file "$2"; then chmod +x "$2"; fi
    shift >/dev/null 2>&1 
    $@ & pid=$! count=0
    while kill -0 $pid >/dev/null 2>&1 ; do
        read -t 1 >/dev/null 2>&1 
        count=$(( $count + 1 ))
        if [ $count -ge $time ]; then
            kill $pid >/dev/null 2>&1 && break
        fi
    done
    wait $pid
    return $?
}

run_jar() {
    local dalvikvm file main 
    #Inspired in the osm0sis method
    if dalvikvm -showversion >/dev/null; then
       dalvikvm=dalvikvm
    elif /system/bin/dalvikvm -showversion >/dev/null; then 
       dalvikvm=/system/bin/dalvikvm
    else
       echo "CANT LOAD DALVIKVM " && return 1
    fi
    file="$1"
    main=$(unzip -p -o "$file" "META-INF/MANIFEST.MF" | grep -m1 "^Main-Class:" | cut -f2 -d: | tr -d " " | dos2unix)
    if [ -z "$main" ]; then
       echo "Cant get main: $file " && return 1
    fi
    shift 1
    $dalvikvm -Djava.io.tmpdir=. -Xnodex2oat -Xnoimage-dex2oat -cp "$file" $main "$@" 2>/dev/null \ || $dalvikvm -Djava.io.tmpdir=. -Xnoimage-dex2oat -cp "$file" $main "$@"
}

run_jar_addon() {
    local file
    file="$1"
    shift 1
    run_jar "$addons/$file" "$@"
}

run_jar_zip() {
    local file result
    file="$1"
    shift 1
    package_extract_file "$file" "$TMP/$(basename "$file")"
    run_jar "$TMP/$(basename "$file")" "$@"
    result=$?
    rm -f "$TMP/$(basename "$file")"
    return $result
}

run_jar_class() {
    local dalvikvm file main class
    #Inspired in the osm0sis method
    if dalvikvm -showversion >/dev/null; then
       dalvikvm=dalvikvm
    elif /system/bin/dalvikvm -showversion >/dev/null; then 
       dalvikvm=/system/bin/dalvikvm
    else
       echo "CANT LOAD DALVIKVM " && return 1
    fi
    file="$1"
    class="$2"
    if [ -z "$class" ]; then
       echo "Class undefined: $file " && return 1
    fi
    shift 2
    $dalvikvm -Djava.io.tmpdir=. -Xnodex2oat -Xnoimage-dex2oat -cp "$file" $class "$@" 2>/dev/null \ || $dalvikvm -Djava.io.tmpdir=. -Xnoimage-dex2oat -cp "$file" $class "$@"
}

run_jar_class_addon() {
    local file
    file="$1"
    shift 1
    run_jar_class "$addons/$file" "$@"
}

run_jar_class_zip() {
    local file result
    file="$1"
    shift 1
    package_extract_file "$file" "$TMP/$(basename "$file")"
    run_jar_class "$TMP/$(basename "$file")" "$@"
    result=$?
    rm -f "$TMP/$(basename "$file")"
    return $result
}

apktool() {
   if [ ! -e /system/framework/framework-res.apk ]; then auto_mount_partitions; fi
   cp -f /system/framework/framework-res.apk "$TMP/1.apk"
   if [ ! -e "$l/apktool.jar" ]; then ui_print " Cant find apktool.jar " && return 1; fi
   run_jar "$l/apktool.jar" --aapt "$l/aapt" -p "$TMP" "$@"
}

sign() {
   if [ ! -e "$l/zipsigner.jar" ]; then ui_print " Cant find zipsigner.jar" && return 1; fi
   run_jar "$l/zipsigner.jar" "$@"
}

decode_xml() {
   local result="$TMP/$RANDOM.xml" return=0
   if [ ! -e "$l/axml.jar" ]; then ui_print " Cant find axml.jar" && return 1; fi
   if ! is_substring "ArrayIndexOutOfBoundsException" "$(run_jar "$l/axml.jar" -d "$1" "$result")" && is_valid "$result"; then
      if [ -n "$2" ]; then copy "$result" "$2" || return=1
      else copy "$result" "$1" || return=1
      fi
   else return=1
   fi
   delete "$result"
   return $return
}

encode_xml() {
   local result="$TMP/$RANDOM.xml" return=0
   if [ ! -e "$l/axml.jar" ]; then ui_print " Cant find axml.jar" && return 1; fi
   if ! is_substring "ArrayIndexOutOfBoundsException" "$(run_jar "$l/axml.jar" -e "$1" "$result")" && is_valid "$result"; then
      if [ -n "$2" ]; then copy "$result" "$2" || return=1
      else copy "$result" "$1" || return=1
      fi
   else return=1
   fi
   delete "$result"
   return $return
}

xml_kit() {
   #XML Tool kit for Dynamic Installer by @BlassGO
   local restore flag
   local xml open close cv code try back i
   local custom1 eq1 eq2 in1 in2
   local native native2 revert result result2 backdir
   local value_1 value_2 content_1 content_2 tag_1 tag_2 in remove print only add al1 al2 bl1 bl2 nas inside
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -open|-o)
       open+=("$2")
       close+=("$3")
       if [[ -z "$2" || -z "$3" ]]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift 3
       ;;
       -change-value)
       cv="$2"
       value_1="$2"
       value_2="$3"
       if [[ -z "$2" || -z "$3" ]]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift 3
       ;;
       -change-content)
       cv="$2"
       content_1="$2"
       content_2="$3"
       if [[ -z "$2" || -z "$3" ]]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift 3
       ;;
       -change-tag)
       cv="$2"
       tag_1="$2"
       tag_2="$3"
       if [[ -z "$2" || -z "$3" ]]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift 3
       ;;
       -add)
       add="$2"
       if [ -z "$2" ]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift 2
       ;;
       -add-inside)
       inside="$2"
       if [ -z "$2" ]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift 2
       ;;
       -after-line|-al)
       al1="$2"
       al2="$3"
       if [[ -z "$2" || -z "$3" ]]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift 3
       ;;
       -before-line|-bl)
       bl1="$2"
       bl2="$3"
       if [[ -z "$2" || -z "$3" ]]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift 3
       ;;
       -remove|-rm)
       remove=true
       shift
       ;;
       -print)
       print=true
       shift
       ;;
       -only-result|-or)
       only=true
       shift
       ;;
       -no-auto-spaces|-nas)
       nas=true
       shift
       ;;
       -in)
       in="$2"
       if [ -z "$2" ]; then echo2 "xml_kit: Invalid line" && return 1; fi
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   array=( "$@" )
   xml=${array[${#array[@]} - 1]}
   if exist "$xml"; then backdir="$xml" && xml=$(cat "$xml") && back="$xml"; else echo2 "xml_kit: Invalid line" && return 1; fi
   unset "array[${#array[@]}-1]"
   [ -n "$in" ] && cv="$in"
   for i in "${!open[@]}"; do
      if [ -z "$xml" ]; then echo2 "xml_kit: Some error in the XML logic" && return 1; fi
      if is_substring '/>' "${close[i]}" || is_substring '</' "${close[i]}"; then custom1=true; fi
      eq1=$(echo "$xml" | grep -Fc "${open[i]}")
      eq2=$(echo "$xml" | grep -Fc "${close[i]}")
      #in1=$(echo "$xml" | grep -Fn "${open[i]}" | cut -d: -f1 | head -n1)
      #in2=$(echo "$xml" | grep -Fn "${close[i]}" | cut -d: -f1 | tail -n1)
      if [[ -z "$custom1" && $eq1 != $eq2 ]]; then
         echo2 "xml_kit: Invalid XML pattern: ${open[i]} ${close[i]}" && return 1
      elif [ $eq1 == 0 ]; then
         echo2 "xml_kit: No results for: ${open[i]} ${close[i]}" && return 1
      fi
      if [ -z "$cv" ] && ! is_substring "${close[i]}" "$(echo "$xml" 2>/dev/null | grep -m1 "${open[i]}")"; then
         xml=$(string -r complete_extract "${open[i]}" "${close[i]}" "$xml")
      elif is_substring "${close[i]}" "$(echo "$xml" 2>/dev/null | grep -m1 "${open[i]}")"; then
         xml=$(echo "$xml" | grep -E ".*${open[i]}.*${close[i]}.*")
      elif [ -n "$cv" ]; then
         xml=$(string -p "$cv" -r complete_extract "${open[i]}" "${close[i]}" "$xml")
      else
         echo2 "xml_kit: Unsupported format" && return 1
      fi
      if ! is_substring "${open[i]}" "$(echo "$xml" 2>/dev/null | head -n1)" || ! is_substring "${close[i]}" "$(echo "$xml" 2>/dev/null | tail -n1)"; then echo2 "xml_kit: Cant get valid result" && return 1; fi
      revert+=("$xml")
   done
   if [ -n "$add" ]; then
      native=$(echo "$xml" | tail -n1)
      if [ -z "$nas" ]; then
         native2=$(echo "$native" | awk '{print $1;}')
         native2=$(string -get-before "$native2" "$native")
         add=$(echo "$add" | sed -e "s/^/$native2/")
      fi
      result=$(string -after-line "$native" "$add" "$xml")
      if [ -z "$result" ]; then echo2 "xml_kit: Cant add content in $native" && return 1; fi
      xml="$result"
   fi
   if [ -n "$inside" ]; then
      native=$(echo "$xml" | grep "." | tail -n2 | head -n1)
      if [ -z "$nas" ]; then
         native2=$(echo "$native" | awk '{print $1;}')
         native2=$(string -get-before "$native2" "$native")
         inside=$(echo "$inside" | sed -e "s/^/$native2/")
      fi
      result=$(string -after-line "$native" "$inside" "$xml")
      if [ -z "$result" ]; then echo2 "xml_kit: Cant add content in $native" && return 1; fi
      xml="$result"
   fi
   if [ -n "$al1" ]; then
      native=$(echo "$xml" | grep -m1 "$al1")
      if [ -z "$nas" ]; then
         native2=$(echo "$native" | awk '{print $1;}')
         native2=$(string -get-before "$native2" "$native")
         al2=$(echo "$al2" | sed -e "s/^/$native2/")
      fi
      result=$(string -after-line "$native" "$al2" "$xml")
      if [ -z "$result" ]; then echo2 "xml_kit: Cant add content in $native" && return 1; fi
      xml="$result"
   fi
   if [ -n "$bl1" ]; then
      native=$(echo "$xml" | grep -m1 "$bl1")
      if [ -z "$nas" ]; then
         native2=$(echo "$native" | awk '{print $1;}')
         native2=$(string -get-before "$native2" "$native")
         bl2=$(echo "$bl2" | sed -e "s/^/$native2/")
      fi
      result=$(string -before-line "$native" "$bl2" "$xml")
      if [ -z "$result" ]; then echo2 "xml_kit: Cant add content in $native" && return 1; fi
      xml="$result"
   fi
   if [ -n "$value_1" ]; then
      native=$(echo "$xml" | grep -om1 "$value_1.*")
      native2=$(string inside_symbol '="' '"' "$native")
      if [[ -z "$native2" || $(echo "$native2" | wc -l) -gt 2 ]]; then echo2 "xml_kit: Cant get value of: $value_1" && return 1; fi
      result=$(string replace "$native2" "$value_2" "$native")
      result=$(string replace "$native" "$result" "$xml")
      if [ -z "$result" ]; then echo2 "xml_kit: Cant change $value_1" && return 1; fi
      xml="$result"
   fi
   if [ -n "$content_1" ]; then
      native=$(echo "$xml" | grep -m1 "$content_1")
      if [[ -z "$native" || $(echo "$native" | wc -l) -gt 2 ]]; then echo2 "xml_kit: Cant get: $content_1" && return 1; fi
      result=$(string replace "$content_1" "$content_2" "$native")
      result=$(string replace "$native" "$result" "$xml")
      if [ -z "$result" ]; then echo2 "xml_kit: Cant change $content_1" && return 1; fi
      xml="$result"
   fi
   if [ -n "$tag_1" ]; then
      native=$(echo "$xml" | grep -m1 "$tag_1")
      native2=$(string inside '>' '<' "$native")
      if [[ -z "$native2" || $(echo "$native2" | wc -l) -gt 2 ]]; then echo2 "xml_kit: Cant get value of tag: $tag_1" && return 1; fi
      result=$(string replace "$native2" "$tag_2" "$native")
      result=$(string replace "$native" "$result" "$xml")
      if [ -z "$result" ]; then echo2 "xml_kit: Cant change $content_1" && return 1; fi
      xml="$result"
   fi
   if [ -n "$remove" ]; then
      result=" "
   fi
   if [ -n "$result" ]; then
      for i in $(echo ${!revert[@]} | rev); do
         result2=$(string replace "${revert[i]}" "$result" "${revert[i - 1]}")
         [ -n "$result2" ] && result="$result2" || break
      done
      if [[ -z "$result" || "$result" == " " ]]; then echo2 "xml_kit: Some error in XML remaking" && return 1; fi
      if [ -z "$only" ]; then result=$(string replace "${revert[0]}" "$result" "$back"); fi
      if [[ -z "$result" || "$result" == " " ]]; then echo2 "xml_kit: Some error in XML remaking" && return 1; fi
   fi
   if [ -n "$result" ]; then
      if [ -z "$print" ]; then
         echo "$result" > "$backdir"
         if is_valid "$backdir"; then set_perm2 0 0 755 "$backdir"
         else echo2 "xml_kit: Cant write $backdir" && return 1
         fi
      else echo "$result"
      fi
   elif [[ -n "$xml" && "$xml" != "$back" ]]; then echo "$xml"
   else echo2 "xml_kit: Unknown problem" && return 1
   fi
}

dynamic_apktool() {
   #Dynamic Apktool for Dynamic Installer by BlassGO
   local file fullname filename filedir outdir folder outfile sign zipa add alladd move fw check out
   local flag current restore ext ps manifest min max try
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -d|-decompile)
       file="$2"
       fullname=$(basename "$2")
       filename=${fullname%.*}
       filedir=$(dirname "$2")
       outdir="$filedir/$filename"
       shift 2
       ;;
       -r|-recompile)
       folder="$2"
       outfile=$(cat "$folder/apktool.yml" | grep -m1 "FileName:" | tr -d " " | cut -f2 -d:)
       ext=${outfile##*.}
       shift 2
       ;;
       -s|-sign)
       sign=true
       shift
       ;;
       -z|-zipalign)
       zipa=true
       shift
       ;;
       -a|-add)
       add=true
       alladd+=$(echo "$2:")
       shift 2
       ;;
       -o|-output)
       move="$2"
       shift 2
       ;;
       -c|-command)
       command="$2"
       shift 2
       ;;
       -ps|-preserve-signature)
       ps=true
       shift
       ;;
       -f|-framework)
       fw="$2"
       shift 2
       ;;
       -im|-include-manifest)
       manifest=true
       shift
       ;;
       -min-sdk)
       min="$2"
       shift 2
       ;;
       -max-sdk)
       max="$2"
       shift 2
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   if [ ! -e /system/build.prop ]; then auto_mount_partitions; fi
   if [ ! -e "$l/apktool.jar" ]; then ui_print " Cant find apktool.jar " && return 1; fi
   if [ ! -e "$l/zipsigner.jar" ]; then ui_print " Cant find zipsigner.jar" && return 1; fi
   if [ ! -e "$l/axml.jar" ]; then ui_print " Cant find axml.jar" && return 1; fi
   echo ">>Dynamic Apktool 1.2.0"
   if [[ -n "$file" && -z "$folder" && -z "$zipa" && -z "$sign" ]]; then
      if [ -n "$fw" ]; then cp -f "$fw" "$TMP/1.apk"; else cp -f /system/framework/framework-res.apk "$TMP/1.apk"; fi
      if [ -n "$move" ]; then
         rm -rf "$move" 2>/dev/null
         echo " L: Decompiling $fullname... "
         echo " L: Please wait..."
         if ! run_jar "$l/apktool.jar" --aapt "$l/aapt" --no-res -p "$TMP" $command d "$file" -o "$move" >/dev/null 2>&1; then echo " ERROR: Cant decompile $fullname" && return 1; fi
         echo " L: Checking results..."
         if [ ! -d "$move" ]; then echo "ERROR: Decompiling $fullname" && return 1; fi
         if [ -n "$add" ]; then
            local IFS=$'\n'
            for add in $(split_string : "$alladd"); do
              echo " L: Adding $(basename "$add")"
              cp -rf "$add" "$move"
            done
         fi
      else
         rm -rf "$outdir" 2>/dev/null
         echo " L: Decompiling $fullname..."
         echo " L: Please wait..."
         if ! run_jar "$l/apktool.jar" --aapt "$l/aapt" --no-res -p "$TMP" $command d "$file" -o "$outdir" >/dev/null 2>&1; then echo " ERROR: Cant decompile $fullname" && return 1; fi
         echo " L: Checking results..."
         if [ ! -d "$outdir" ]; then echo "ERROR: Decompiling $fullname" && return 1; fi
         if [ -n "$add" ]; then
            local IFS=$'\n'
            for add in $(split_string : "$alladd"); do
              echo " L: Adding $(basename "$add")"
              cp -rf "$add" "$outdir"
            done
         fi
      fi
      echo " L: Success "
   elif [[ -z "$file" && -n "$folder" ]]; then
         if [ -n "$fw" ]; then cp -f "$fw" "$TMP/1.apk"; else cp -f /system/framework/framework-res.apk "$TMP/1.apk"; fi
         rm -f "$folder/try.apk" 2>/dev/null
         rm -rf "$folder/dist" 2>/dev/null
         echo " L: Recompiling $(basename "$folder")... "
         if [[ -n "$min" || -n "$max" ]]; then
            if decode_xml "$folder/AndroidManifest.xml"; then
               if [ -n "$min" ]; then
                  xml_kit -open '<manifest' '</manifest>' -open '<uses-sdk' '>' -change-value android:minSdkVersion $min "$folder/AndroidManifest.xml"
                  min=$(sed -n 's/.*android:minSdkVersion="\([^"]*\).*$/\1/p' "$folder/AndroidManifest.xml")
                  [ -n "$min" ] && echo " L: Min-sdk: $min"
               fi
               if [ -n "$max" ]; then
                  xml_kit -open '<manifest' '</manifest>' -open '<uses-sdk' '>' -change-value android:maxSdkVersion $max "$folder/AndroidManifest.xml"
                  max=$(sed -n 's/.*android:maxSdkVersion="\([^"]*\).*$/\1/p' "$folder/AndroidManifest.xml")
                  [ -n "$max" ] && echo " L: Max-sdk: $max"
               fi
               encode_xml "$folder/AndroidManifest.xml"
            fi
         fi
         if [ -n "$manifest" ]; then
            echo " L: Including AndroidManifest.xml"
            cp -f "$folder/AndroidManifest.xml" "$folder/original/AndroidManifest.xml"
         fi
         if [ -z "$ps" ]; then
            echo " L: Using all changes..."
            echo " L: Please wait..."
            run_jar "$l/apktool.jar" --aapt "$l/aapt" -p "$TMP" -f $command b "$folder" -o "$folder/try.apk" >/dev/null 2>&1
         else
            echo " L: Saving signature..."
            echo " L: Please wait..."
            run_jar "$l/apktool.jar" --aapt "$l/aapt" -p "$TMP" -f $command --copy-original b "$folder" -o "$folder/try.apk" >/dev/null 2>&1
         fi
         if [ ! -e "$folder/try.apk" ]; then echo "ERROR: Compiling $outfile" && return 1; fi
         if [ -n "$add" ]; then
            local IFS=$'\n'
            current=${PWD}
            for add in $(split_string : "$alladd"); do
                echo " L: Adding $(basename "$add")"
                cd "$(dirname "$add")"
                zip -ur "$folder/try.apk" "$(basename "$add")" >/dev/null
            done
            cd "$current"
         fi
         if [ -n "$sign" ]; then
            echo " L: Signing $outfile"
            run_jar "$l/zipsigner.jar" "$folder/try.apk" "$folder/try.zp" >/dev/null
            if [ ! -e "$folder/try.zp" ]; then echo "ERROR: sign $outfile" && return 1; fi
            mv -f "$folder/try.zp" "$folder/try.apk"
         fi
         if [[ -n "$zipa" || "$ext" == "apk" || -n "$ps" ]]; then
            echo " L: Zipaligning $(basename "$outfile")"
            zipalign -f -v 4 "$folder/try.apk" "$folder/try.zp" >/dev/null
            if [ ! -e "$folder/try.zp" ]; then echo "ERROR: zipalign $outfile" && return 1; fi
            mv -f "$folder/try.zp" "$folder/try.apk"
         fi
         if [[ -n "$move" && ! -d "$(dirname "$move")" ]]; then mkdir -p "$(dirname "$move")"; fi
         if [ -n "$move" ]; then
            cp -pf "$folder/try.apk" "$move"
            if is_valid "$move"; then
               rm -f "$folder/try.apk"
               echo " L: Success $(basename "$move")" && return 0
            else
               echo " L: ERROR $(basename "$move")" && return 1
            fi
         else
            mkdir -p "$folder/dist"
            cp -pf "$folder/try.apk" "$folder/dist/$outfile"
            if is_valid "$folder/dist/$outfile"; then
               rm -f "$folder/try.apk"
               echo " L: Success $outfile" && return 0
            else
               echo " L: ERROR $outfile" && return 1
            fi
         fi
   else
      echo "dynamic_apktool: Invalid line" && return 1
   fi
}

find_apk() {
   local userlist package try restore flag re result
   local array path try2 limit count=0 return=1
   local check_split splits overlays check
   if ! aapt version >/dev/null; then echo " CANT LOAD AAPT: U cant use find_apk " && return 1; fi
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -r|-recursive)
       re=true
       shift
       ;;
       -l|-limit)
       limit="$2"
       shift 2
       ;;
       -is|-include-splits)
       splits=true
       shift
       ;;
       -io|-include-overlays)
       overlays=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   delete "$TMP/userlist.txt"
   delete "$TMP/packages.txt"
   if defined limit && ! is_number $limit; then echo2 " find_apk: Invalid line" && return 1; fi
   array=( "$@" )
   path=${array[${#array[@]} - 1]}
   unset "array[${#array[@]}-1]"
   while read userlist; do
       if undefined userlist; then echo "find_apk: Cant find any apk in $path " && return 1; fi
       package=
       package=$(apk_package "$userlist")
       if defined package; then
          echo "$userlist" >> "$TMP/userlist.txt"
          echo "$(basename "$userlist")=$package" >> "$TMP/packages.txt"
       fi
   done <<< $(find "$path" -type f -name "*.apk")
   for try in "${array[@]}"; do
     while read try2; do
        undefined try2 && continue
        package=
        package=$(get_file_prop "$TMP/packages.txt" "$try2")
        check=$(grep -m1 "$try2" "$TMP/userlist.txt")
        check_split=$(aapt dump badging "$check" | sed -n "s/.* split='\([^']*\).*$/\1/p")
        check_overlay=$(aapt dump xmlstrings "$check" AndroidManifest.xml | grep -w " overlay")
        if [ -z "$re" ]; then
           if [[ -z "$splits" && -z "$overlays" ]]; then
              if [[ -z "$check_split" && -z "$check_overlay" && "$package" == "$try" ]]; then echo "$(grep -m1 "$try2" "$TMP/userlist.txt")" && return=0 && count=$(( $count + 1 )); fi;
           elif [ -n "$splits" ]; then
              if [[ -z "$check_overlay" && "$package" == "$try" ]]; then echo "$(grep -m1 "$try2" "$TMP/userlist.txt")" && return=0 && count=$(( $count + 1 )); fi;
           elif [ -n "$overlays" ]; then
              if [[ -z "$check_split" && "$package" == "$try" ]]; then echo "$(grep -m1 "$try2" "$TMP/userlist.txt")" && return=0 && count=$(( $count + 1 )); fi;
           else
              if [[ "$package" == "$try" ]]; then echo "$(grep -m1 "$try2" "$TMP/userlist.txt")" && return=0 && count=$(( $count + 1 )); fi;
           fi
        else
           result=
           result=$(grep -m1 "$try2" "$TMP/userlist.txt")
           if [ -n "$result" ]; then echo "$result" && return=0 && count=$(( $count + 1 )); fi
        fi
        if [[ -n "$limit" && "$limit" == "$count" ]]; then break; fi
     done <<< $(grep "$try" "$TMP/packages.txt" | cut -d '=' -f1)
   done
   return $return
}

apk_package() {
   local package
   if ! aapt version >/dev/null; then echo " CANT LOAD AAPT: U cant use apk_package " && return 1; fi
   package=$(aapt dump badging "$1" | sed -n "s/.*package: name='\([^']*\).*$/\1/p" 2>/dev/null)
   if [ -n "$package" ]; then echo "$package"; else return 1; fi
}

apk_pkg() {
   apk_package "$@"
}

patch_apk() {
    local current=${PWD} stock new
    if ! exist "$1" "$2"; then echo2 "patch_apk: Invalid line" && return 1; fi
    cp -pf "$2" "$TMP"
    savestate stock "$TMP/$(basename "$2")"
    cd "$1" && zip -r "$TMP/$(basename "$2")" * >/dev/null
    cd "$current"
    savestate new "$TMP/$(basename "$2")"
    if [[ "$stock" != "$new" ]]; then echo "Patched: $2"; else echo "No changes: $2" && return 1; fi
    if [[ "$3" == "zipalign" ]]; then
       zipalign -f -v 4 "$TMP/$(basename "$2")" "$TMP/$(basename "$2").zp" >/dev/null
       if [ -e "$TMP/$(basename "$2").zp" ]; then
          echo2 "Zipaligned: $2"
          mv -f "$TMP/$(basename "$2").zp" "$TMP/$(basename "$2")"
       else
          echo2 "ERROR: zipalign $2" && return 1
       fi
    fi
    if [[ "$3" == "sign" ]]; then
       if [ ! -e $l/zipsigner.jar ]; then ui_print " Cant find zipsigner.jar " && return 1; fi
       run_jar "$l/zipsigner.jar" "$TMP/$(basename "$2")" "$TMP/$(basename "$2").zp" >/dev/null
       if [ -e "$TMP/$(basename "$2").zp" ]; then
          echo2 "Signed: $2"
          mv -f "$TMP/$(basename "$2").zp" "$TMP/$(basename "$2")"
       else
          echo2 "ERROR: sign $2" && return 1
       fi
    fi
    if is_valid "$TMP/$(basename "$2")"; then inject "$TMP/$(basename "$2")" "$(dirname "$2")"; else echo2 "FATAL ERROR: $TMP/$(basename "$2")" && return 1; fi
}

patch_apk_addon() {
   patch_apk "$addons/$1" "$2" "$3"
}

patch_apk_zip() {
    local result
    rm -rf "$TMP/patch_apk"
    package_extract_dir "$1" "$TMP/patch_apk"
    patch_apk "$TMP/patch_apk" "$2" "$3"
    result=$?
    rm -rf "$TMP/patch_apk"
    return $result
}

progress() {
    # command & progress
    local pid=$! huh delay=0.1 limit=10 count=0 anim='|/-\' finish=10 mark="=========================================="
    while kill -0 "$pid" 2> /dev/null; do
        sleep $delay
        local temp=${anim#?}
        local pd=$(( $count * 73 / $finish ))
        if [[ "$count" == "2" ]]; then sleep 0.3 && count=$(( $count + 1 )); fi
        if [[ "$count" == "3" ]]; then sleep 0.3 && count=$(( $count + 1 )); fi
        if [[ "$count" -le "4" ]]; then count=$(( $count + 1 )); fi
        printf "\r %c %3d.%1d%% %.${pd}s" $anim $(( $count * 100 / $finish )) $(( ($count * 1000 / $finish) % 10 )) $mark
        local anim=$temp${anim%"$temp"}
    done
    while [[ $count -lt $limit ]]; do
        sleep $delay
        local temp=${anim#?}
        local pd=$(( $count * 73 / $finish ))
        count=$(( $count + 1 ))
        printf "\r %c %3d.%1d%% %.${pd}s" $anim $(( $count * 100 / $finish )) $(( ($count * 1000 / $finish) % 10 )) $mark
        local anim=$temp${anim%"$temp"}
    done
    echo
}

progress_print() {
    # command & progress_print " file to print"
    local pid=$! check check2 idk=0 file="$1" delay=0 count=0
    local huh limit uwu
    limit=$(cat "$file" | wc -l)
    huh=$(( $limit / 4 ))
    while read uwu; do
       while kill -0 "$pid" 2> /dev/null; do
           count=$(( $count + 1 ))
           sleep $delay
           if [[ "$uwu" != "$check" ]]; then
              if [[ "$count" -lt "$huh" ]]; then 
                 ui_print "$uwu"
              fi
              if [[ "$count" -lt "$(( $count * 2 ))" ]]; then 
                 ui_print "$uwu"
              fi
           fi
           check="$uwu"
       done
       while [[ "$idk" -lt "$limit" ]]; do
         if [[ "$uwu" != "$check2" && "$uwu" != "$check" ]]; then
            idk=$(( $idk + 1 ))
            sleep $delay
            ui_print "$uwu"
            check2="$uwu"
         else
            break
         fi
       done
    done < "$file"
    echo
}


progress_script() {
   local huh
   #progress_script script/commands
   huh="$@"
   if [ -z "$huh" ]; then return; fi
   $("$@" >/dev/null 2>&1) & progress
}

start_loading() {
   #start_loading -s 10 -f 100 -a '|/-\' -l [..................................]
   #start_loading -s(tart) 10 -f(inish) 100 -d(elay) 0.5 -a(nimation) '|/-\' -l(inear) [..................................]
   local complete=$(getvalue s $@ 2>/dev/null)
   export mark=$(getvalue l $@ 2>/dev/null)
   export loafinish=$(getvalue f $@ 2>/dev/null)
   export delay=$(getvalue d $@ 2>/dev/null)
   export loacount=0
   export anim=$(getvalue a $@ 2>/dev/null)
   for huh in complete loafinish; do
      uwu=$(checkvar $huh)
      if [ -z "$uwu" ]; then
         echo "start loading: Fatal line" && return
      fi
   done
   if [ -z "$delay" ]; then export delay="0.3" ; fi;
   while [[ $loacount -lt $loafinish && $loacount -lt $complete ]]; do
     sleep $delay
     local temp=${anim#?}
     export loacount=$(( $loacount + 1 ))
     export pd=$(( $loacount * 73 / $loafinish ))
     if [[ -n "$mark" && -n "$anim" ]]; then
        printf "\r %c %3d.%1d%% %.${pd}s" $anim $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 )) $mark
        local anim=$temp${anim%"$temp"}
     elif [[ -z "$mark" && -n "$anim" ]]; then
        printf "\r %c %3d.%1d%%" $anim $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 ))
        local anim=$temp${anim%"$temp"}
     elif [[ -n "$mark" && -z "$anim" ]]; then
        printf "\r%3d.%1d%% %.${pd}s" $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 )) $mark
     else
       printf "\r%3d.%1d%%" $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 ))
     fi
   done
   if [[ "$loacount" -ge "$loafinish" ]]; then echo ; fi;
}

add_loading() {
   local complete=$1
   local add=0
   for huh in complete loafinish; do
      uwu=$(checkvar $huh)
      if [ -z "$uwu" ]; then
         echo "add loading: Fatal line or undefined start_loading" && return
      fi
   done
   while [[ $loacount -lt $loafinish && $add -lt $complete ]]; do
     sleep $delay
     local temp=${anim#?}
     export loacount=$(( $loacount + 1 ))
     add=$(( $add + 1 ))
     export pd=$(( $loacount * 73 / $loafinish ))
     if [[ -n "$mark" && -n "$anim" ]]; then
        printf "\r %c %3d.%1d%% %.${pd}s" $anim $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 )) $mark
        local anim=$temp${anim%"$temp"}
     elif [[ -z "$mark" && -n "$anim" ]]; then
        printf "\r %c %3d.%1d%%" $anim $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 ))
        local anim=$temp${anim%"$temp"}
     elif [[ -n "$mark" && -z "$anim" ]]; then
        printf "\r%3d.%1d%% %.${pd}s" $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 )) $mark
     else
       printf "\r%3d.%1d%%" $(( $loacount * 100 / $loafinish )) $(( ($loacount * 1000 / $loafinish) % 10 ))
     fi
   done
   if [[ "$loacount" -ge "$loafinish" ]]; then echo ; fi;
}

smali_kit() {
   #Smali Tool kit for Dynamic Installer by BlassGO
   local dir num line liner old new count=0 restore load try log
   local file path method replace limit rim newline oldline check stock edit smaliname remake
   local get al al_add bl bl_add staticname dim dim_oldline justprint printpath prev dm
   local restore flag 
   delete "$TMP/smali_kit"
   restore=()
   while [[ $# -gt 0 ]]; do
   flag="$1"
   case $flag in
       -f|-file)
       file="$2"
       shift 2
       ;;
       -d|-dir)
       path="$2"
       shift 2
       ;;
       -m|-method)
       method="$2"
       shift 2
       ;;
       -r|-replace)
       replace="$2"
       shift 2
       ;;
       -rim|-replace-in-method)
       rim=true
       oldline="$2"
       newline="$3"
       shift 3
       ;;
       -dim|-delete-in-method)
       dim=true
       dim_oldline="$2"
       shift 2
       ;;
       -re|-remake)
       remake="$2"
       shift 2
       ;;
       -al|-after-line)
       al="$2"
       al_add="$3"
       shift 3
       ;;
       -bl|-before-line)
       bl="$2"
       bl_add="$3"
       shift 3
       ;;
       -c|-check)
       check=true
       shift
       ;;
       -n|-name)
       smaliname="$2"
       shift 2
       ;;
       -sn|-static-name)
       staticname="$2"
       shift 2
       ;;
       -l|-limit)
       limit="$2"
       shift 2
       ;;
       -pp|-print-path)
       printpath=true
       shift
       ;;
       -dm|-delete-method)
       dm=true
       shift
       ;;
       *)   
       restore+=("$1")
       shift
       ;;
   esac
   done
   set -- "${restore[@]}"
   if [[ -z "$file" && -n "$path" && -n "$method" ]]; then
      grep -rnw "$path" -e "$method" | while read huh; do
         undefined huh && break
         stock=
         edit=
         dir=$(echo "$huh" | cut -f1 -d:)
         num=$(echo "$huh" | cut -f2 -d:)
         liner=$(echo "$huh" | cut -f3 -d:)
         if [[ "$liner" == *".method"* && "$liner" != *".method abstract"* && "$liner" != *".method public abstract"* ]]; then
            if [[ -n "$staticname" && "$(basename "$dir")" != "$staticname" ]]; then continue; fi
            if [[ -n "$smaliname" && "$(basename "$dir")" != *"$smaliname"* ]]; then continue; fi
            if [ -n "$printpath" ]; then if [[ "$dir" != "$prev" ]]; then 
               count=$(( $count + 1 ))
               echo "$dir"
               echo 0 > "$TMP/smali_kit"
               if [[ -n "$limit" && "$limit" == "$count" ]]; then break; fi
               prev="$dir" && justprint=true && continue
            fi; fi
            line=$(echo "$liner" | sed -e 's/[]\/$*.^[]/\\&/g')
            savestate stock "$dir"
            if [[ -z "$replace" && -z "$rim" && -z "$remake" && -z "$al" && -z "$bl" && -z "$dim" && -z "$printpath" && -z "$dm" ]]; then
               justprint=true
               echo "path=$dir"
               sed -n "/$line/,/\.end method/p" "$dir"
            fi
            if [ -n "$replace" ]; then
               load=$(cat "$dir")
               old=$(sed -n "/$line/,/\.end method/p" "$dir")
               echo "${load/"$old"/"$replace"}" > "$dir"
            fi
            if [[ -n "$rim" && -n "$oldline" && -n "$newline" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$dir")
               try=${old/"$oldline"/"$newline"}
               load=$(cat "$dir")
               echo "${load/"$old"/"$try"}" > "$dir"
            fi
            if [[ -n "$dim" && -n "$dim_oldline" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$dir")
               try=${old//"$dim_oldline"/}
               load=$(cat "$dir")
               echo "${load/"$old"/"$try"}" > "$dir"
            fi
            if [ -n "$remake" ]; then
               old=$(sed -n "/$line/,/\.end method/p" "$dir")
               echo "${liner}" > "$TMP/re.tmp"
               echo "$remake" >> "$TMP/re.tmp"
               echo "${n}.end method" >> "$TMP/re.tmp"
               try=$(cat "$TMP/re.tmp")
               rm -f "$TMP/re.tmp" 2>/dev/null
               load=$(cat "$dir")
               echo "${load/"$old"/"$try"}" > "$dir"
            fi
            if [[ -n "$bl" && -n "$bl_add" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$dir") 
               if [ $(echo "$bl_add" | wc -l) -gt 2 ]; then
                  get=$(echo "$bl_add" | sed ':a;N;$!ba;s/\n/\\n/g' | sed 's/\$/\\$/g')
               else
                  get="$bl_add"
               fi
               try=$(echo "$old" | sed -e '/'"$bl"'/i\'"$get")
               load=$(cat "$dir")
               echo "${load/"$old"/"$try"}" > "$dir"
            fi
            if [[ -n "$al" && -n "$al_add" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$dir") 
               if [ $(echo "$al_add" | wc -l) -gt 2 ]; then
                  get=$(echo "$al_add" | sed ':a;N;$!ba;s/\n/\\n/g' | sed 's/\$/\\$/g')
               else
                  get="$al_add"
               fi
               try=$(echo "$old" | sed -e '/'"$al"'/a\'"$get")
               load=$(cat "$dir")
               echo "${load/"$old"/"$try"}" > "$dir"
            fi
            if [ -n "$dm" ]; then
               load=$(cat "$dir")
               old=$(sed -n "/$line/,/\.end method/p" "$dir") 
               echo "${load//"$old"/}" > "$dir"
            fi
            savestate edit "$dir"
            if [ -z "$printpath" ]; then count=$(( $count + 1 )); fi
            if [ -n "$check" ]; then if [[ "$edit" != "$stock" ]]; then ui_print "Edited: "$dir""; else ui_print "Nothing: "$dir""; fi; fi
            if [[ "$edit" != "$stock" ]]; then echo 0 > "$TMP/smali_kit"; else echo 1 > "$TMP/smali_kit"; fi
            if [ -n "$justprint" ]; then echo 0 > "$TMP/smali_kit"; fi
            if [[ -n "$limit" && "$limit" == "$count" ]]; then break; fi
         fi
      done
   elif [[ -n "$file" && -z "$path" && -n "$method" ]]; then
      grep -nw "$file" -e "$method" | while read huh; do
         undefined huh && break
         stock=
         edit=
         num=$(echo "$huh" | cut -f1 -d:)
         liner=$(echo "$huh" | cut -f2 -d:)
         if [[ "$liner" == *".method"* && "$liner" != *".method abstract"* && "$liner" != *".method public abstract"* ]]; then
            if [[ -n "$staticname" && "$(basename "$file")" != "$staticname" ]]; then continue; fi
            if [[ -n "$smaliname" && "$(basename "$file")" != *"$smaliname"* ]]; then continue; fi
            line=$(echo "$liner" | sed -e 's/[]\/$*.^[]/\\&/g')
            savestate stock "$file"
            if [[ -z "$replace" && -z "$rim" && -z "$remake" && -z "$al" && -z "$bl" && -z "$dm" ]]; then
               justprint=true
               echo "path="$dir""
               sed -n "/$line/,/\.end method/p" "$file"
            fi
            if [ -n "$replace" ]; then
               load=$(cat "$file")
               old=$(sed -n "/$line/,/\.end method/p" "$file")
               echo "${load/"$old"/"$replace"}" > "$file"
            fi
            if [[ -n "$rim" && -n "$oldline" && -n "$newline" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$file")
               try=${old/"$oldline"/"$newline"}
               load=$(cat "$file")
               echo "${load/"$old"/"$try"}" > "$file"
            fi
            if [[ -n "$dim" && -n "$dim_oldline" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$file")
               try=${old//"$dim_oldline"/}
               load=$(cat "$file")
               echo "${load/"$old"/"$try"}" > "$file"
            fi
            if [ -n "$remake" ]; then
               old=$(sed -n "/$line/,/\.end method/p" "$file")
               echo "${liner}" > "$TMP/re.tmp"
               echo "$remake" >> "$TMP/re.tmp"
               echo "${n}.end method" >> "$TMP/re.tmp"
               try=$(cat "$TMP/re.tmp")
               rm -f "$TMP/re.tmp" 2>/dev/null
               load=$(cat "$file")
               echo "${load/"$old"/"$try"}" > "$file"
            fi
            if [[ -n "$bl" && -n "$bl_add" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$file") 
               echo "$bl_add" > "$TMP/bl.tmp"
               get=$(sed '$!s/$/\\/' "$TMP/bl.tmp")
               rm -f "$TMP/bl.tmp"
               try=$(echo "$old" | sed "/$bl/i $get")
               load=$(cat "$file")
               echo "${load/"$old"/"$try"}" > "$file"
            fi
            if [[ -n "$al" && -n "$al_add" ]]; then
               old=$(sed -n "/$line/,/\.end method/p" "$file") 
               echo "$al_add" > "$TMP/al.tmp"
               get=$(sed '$!s/$/\\/' "$TMP/al.tmp")
               rm -f "$TMP/al.tmp"
               try=$(echo "$old" | sed -e "/$al/a $get")
               load=$(cat "$file")
               echo "${load/"$old"/"$try"}" > "$file"
            fi
            if [ -n "$dm" ]; then
               load=$(cat "$file")
               old=$(sed -n "/$line/,/\.end method/p" "$file") 
               echo "${load//"$old"/}" > "$file"
            fi
            savestate edit "$file"
            count=$(( $count + 1 ))
            if [ -n "$check" ]; then if [[ "$edit" != "$stock" ]]; then ui_print "Edited: "$file""; else ui_print "Nothing: "$file""; fi; fi
            if [[ "$edit" != "$stock" ]]; then echo 0 > "$TMP/smali_kit"; else echo 1 > "$TMP/smali_kit"; fi
            if [ -n "$justprint" ]; then echo 0 > "$TMP/smali_kit"; fi
            if [[ -n "$limit" && "$limit" == "$count" ]]; then break; fi
         fi
      done
   else
      echo " smali_kit: Invalid line " && return 1
   fi
   if [ -f "$TMP/smali_kit" ]; then return $(cat "$TMP/smali_kit"); else return 1; fi
}

apex_pkg() {
    #Based on Magisk method
    local pattern='s/.*"name":[^"]*"\([^"]*\).*/\1/p' apex="$1" dest
    local pattern2='s/.*package="\([^"]*\).*$/\1/p'
    if [ -f "$apex/apex_manifest.json" ]; then
        dest=$(sed -n $pattern "$apex/apex_manifest.json")
    elif [ -f "$apex/apex_manifest.pb" ]; then
        dest=$(strings "$apex/apex_manifest.pb" | head -n 1)
    fi
    [ ! -z "$dest" ] && echo "$dest" && return
    dest=$(unzip -qp "$apex" apex_manifest.pb | strings | head -n 1)
    [ -z "$dest" ] && dest=$(unzip -qp "$apex" apex_manifest.json | sed -n $pattern)
    [ -z "$dest" ] && dest=$(unzip -qp "$apex" apex_build_info.pb | sed -n $pattern2)
    [ ! -z "$dest" ] && echo "$dest" || return 1
}

getarch() {
  local try info
  if [ ! -e /system/build.prop ]; then
     API=`getprop ro.build.version.sdk`
     ABI=`getprop ro.product.cpu.abi | cut -c-3`
     ABI2=`getprop ro.product.cpu.abi2 | cut -c-3`
     ABILONG=`getprop ro.product.cpu.abi`
     PROC=`getprop ro.product.board`
  else
     API=`get_file_prop /system/build.prop ro.build.version.sdk`
     ABI=`get_file_prop /system/build.prop ro.product.cpu.abi | cut -c-3`
     ABI2=`get_file_prop /system/build.prop ro.product.cpu.abi2 | cut -c-3`
     ABILONG=`get_file_prop /system/build.prop ro.product.cpu.abi`
     PROC=`get_file_prop /system/build.prop ro.hardware.chipname`
  fi
  if [ ! -e /vendor/build.prop ]; then
     virtual_partitions=`getprop ro.virtual_ab.enabled`
     dynamic_partitions=`getprop ro.boot.dynamic_partitions`
  else
     virtual_partitions=`get_file_prop /vendor/build.prop ro.virtual_ab.enabled`
     dynamic_partitions=`get_file_prop /vendor/build.prop ro.boot.dynamic_partitions`
  fi
  for slot in "$(grep_cmdline androidboot.slot_suffix)" "$(grep_cmdline androidboot.slot)" "$(getprop ro.boot.slot_suffix)"; do
     if [ -n "$slot" ]; then
        if is_substring _ "$slot"; then export slot=$slot && break; else export slot=_${slot} && break; fi
     fi
  done
  if [ -z "$PROC" ]; then
     PROC=$(grep_cmdline androidboot.hardware)
  fi
  encrypted=false
  grep ' /data ' /proc/mounts | grep -q 'dm-' && encrypted=true
  [ "$(getprop ro.crypto.state)" = "encrypted" ] && encrypted=true
  touch /data/.rw && rm /data/.rw && encrypted=false
  status=$(getenforce)
  arch=arm
  arch32=arm
  is64bit=false
  if [ -e "/proc/cpuinfo" ]; then 
     try=$(cat /proc/cpuinfo | grep -m1 "architecture" | cut -d':' -f2 | tr -d " ")
     if is_number "$try"; then
        if [[ "$try" == "8" ]]; then native_arch=arm64
        elif [[ "$try" == "7" ]]; then native_arch=arm
        fi
     else
        echo2 " Warning: ABnormal architecture"
     fi
     if $(cat /proc/cpuinfo | grep -m1 "Hardware" | grep -q "Qualcomm"); then chipname=snapdragon
     elif $(cat /proc/cpuinfo | grep -m1 "Hardware" | grep -q "Kirin"); then chipname=kirin
     elif $(cat /proc/cpuinfo | grep -m1 "Hardware" | grep -q "MT"); then chipname=mediatek
     elif defined PROC && is_substring "exynos" "$PROC"; then chipname=exynos
     fi
  fi
  if [ "$ABI" = "x86" ]; then arch=x86; arch32=x86; fi;
  if [ "$ABI2" = "x86" ]; then arch=x86; arch32=x86; fi;
  if [ "$ABILONG" = "arm64-v8a" ]; then arch=arm64; arch32=arm; is64bit=true; base_lib=64; fi;
  if [ "$ABILONG" = "x86_64" ]; then arch=x64; arch32=x86; is64bit=true; base_lib=64; fi;
  echo2 "------------Device INFO------------"
  for info in API ABI ABI2 ABILONG PROC arch arch32 native_arch is64bit chipname status encrypted slot dynamic_partitions virtual_partitions; do
     if defined $info; then echo2 "$info=$(checkvar $info)"; fi
  done
  echo2 "-----------------------------------"
}

getsecurity() {
  local avb avb2 info
  if ! can_run avbctl; then echo2 "FATAL ERROR: Please import/use valid avbctl" && return 1; fi
  if $is64bit; then
     avb=$(avbctl get-verity)
     avb2=$(avbctl get-verification)
     if is_substring "verity is enabled" "$avb"; then VERITY=enabled
     elif is_substring "verity is disabled" "$avb"; then VERITY=disabled
     fi
     if is_substring "verification is enabled" "$avb2"; then VERIFICATION=enabled
     elif is_substring "verification is disabled" "$avb2"; then VERIFICATION=disabled
     fi
  fi
  for info in VERITY VERIFICATION; do
     if defined $info; then echo2 "> $info=$(checkvar $info)"; fi
  done
  echo2 " "
}

disable_avb() {
   #It may cause problems in samsung devices (Risk)
   if ! can_run avbctl; then echo2 "FATAL ERROR: Please import/use valid avbctl" && return 1; fi
   getsecurity 2>/dev/null
   if $is64bit; then
      if [[ "$VERIFICATION" == "enabled" ]]; then avbctl --force disable-verification > /dev/null; fi
      if [[ "$VERITY" == "enabled" ]]; then avbctl --force disable-verity > /dev/null; fi
   fi
   getsecurity
}

enable_avb() {
   if ! can_run avbctl; then echo2 "FATAL ERROR: Please import/use valid avbctl" && return 1; fi
   getsecurity 2>/dev/null
   if $is64bit; then
      if [[ "$VERIFICATION" == "disabled" ]]; then avbctl --force enable-verification > /dev/null; fi
      if [[ "$VERITY" == "disabled" ]]; then avbctl --force enable-verity > /dev/null; fi
   fi
   getsecurity
}

getbins() {
  local support pos
  unset bins
  while read support; do
     while read pos; do
      if [ -d "$support" ] && ! is_substring "$pos" "$bins"; then export bins+="$pos:" && echo "$pos"; fi
     done <<< $(basename "$(ls "$support" 2>/dev/null)")
  done <<< $(split_string : "$PATH")
}

run() {
    local current file var
    current=$(dirname "$2")
    file=$(basename "$2")
    var="$1"
    shift 2
    chmod +x "$current/$file"
    setdefault "$var" "$($current/$file "$@" 2>&1)"
}

run_addon() {
    local file var
    file="$2"
    var="$1"
    shift 2
    run "$var" "$addons/$file" "$@"
}

run_zip() {
    local file var
    file="$2"
    var="$1"
    shift 2
    package_extract_file "$file" "$TMP/$(basename "$file")"
    run "$var" "$TMP/$(basename "$file")" "$@"
    rm -f "$TMP/$(basename "$file")"
}

package_extract_file() { 
   local file ext
   if [[ -n "$1" && -n "$2" ]]; then
      if [ ! -d "$(dirname "$2")" ]; then mkdir -p "$(dirname "$2")" && set_perm2 0 0 755 "$(dirname "$2")"; fi
      file=$(basename "$2")
      ext=${file##*.}
      unzip -p -o "$installzip" "$1" > "$2"
      if exist "$2"; then if [[ "$ext" == "sh" ]]; then chmod +x "$2"; else set_perm2 0 0 644 "$2"; fi
      else return 1
      fi
   elif [ -n "$1" ]; then
      unzip -p -o "$installzip" "$1" || return 1
   else
      return 1
   fi
}

package_extract_dir() {
  local outfile file ext return=0 a
  while read a; do
    if undefined a; then return=1 && break; fi
    if [[ -n "$1" && -n "$2" ]]; then
       outfile=$(echo "$a" | sed "s|${1}|${2}|");
       file=$(basename "$outfile")
       ext=${file##*.}
       if [ ! -d "$(dirname "$outfile")" ]; then mkdir -p "$(dirname "$outfile")" && set_perm2 0 0 755 "$(dirname "$outfile")"; fi
       unzip -p -o "$installzip" "$a" > "$outfile"
       if exist "$outfile"; then if [[ "$ext" == "sh" ]]; then chmod +x "$outfile"; else set_perm2 0 0 644 "$outfile"; fi;
       else return=1 && continue
       fi
    elif [ -n "$1" ]; then
       unzip -p -o "$installzip" "$a" || return=1
    else return=1 && break
    fi
  done <<< $(unzip -l "$installzip" | tail -n+4 | grep -v '/$' | grep -o " $1.*$" | cut -c2-)
  return $return
}

echo2() {
   >&2 echo "$@"
}

getblocks() {
   local block mapper bd result base
   unset all_partitions
   for block in /dev/block/platform/*/by-name/*; do
       if [ -e "$block" ]; then
          result=
          base=
          base=$(basename "$block")
          result=$(readlink -f "$block")
          if defined result && exist "$result"; then
             base=$(string lower "$base")
             setdefault "$base" "$result"
             echo2 "$base=$result"
             export all_partitions+="$result:"
          fi
       fi
   done
   for block in /dev/block/by-name/*; do
       if [ -e "$block" ]; then
          result=
          base=
          base=$(basename "$block")
          result=$(readlink -f "$block")
          if defined result && exist "$result" && ! is_substring "$result" "$all_partitions"; then
             base=$(string lower "$base")
             setdefault "$base" "$result"
             echo2 "$base=$result"
             export all_partitions+="$result:"
          fi
       fi
   done 
   if [[ "$dynamic_partitions" == "true" ]]; then
       while read mapper; do
           if [ -e "$mapper" ]; then
              result=
              base=
              base=$(basename "$mapper")
              result=$(readlink -f "$mapper")
              if defined result && exist "$result" && ! is_substring "$result" "$all_partitions"; then
                 base=$(string lower "$base")
                 setdefault "$base" "$result"
                 echo2 "$base=$result"
                 export all_partitions+="$result:"
              fi
           fi
       done <<< $(find /dev/block/mapper -mindepth 1 -maxdepth 1 \( -type b -o -type c -o -type l \)) 
   fi
   if [ -d /dev/block/bootdevice ]; then
      while read bd; do
           if [ -e "$bd" ]; then
              result=
              base=
              base=$(basename "$bd")
              result=$(readlink -f "$bd")
              if defined result && exist "$result" && ! is_substring "$result" "$all_partitions"; then
                 base=$(string lower "$base")
                 setdefault "$base" "$result"
                 echo2 "$base=$result"
                 export all_partitions+="$result:"
              fi
           fi
       done <<< $(find /dev/block/bootdevice -mindepth 1 -maxdepth 1 \( -type b -o -type c -o -type l \)) 
   fi
}

fprint() {
  local line
  while IFS='' read -r line || [[ -n "$line" ]]; do
    ui_print "$line";
  done < "$1";
}

fprint_zip() {
  package_extract_file "$1" "$TMP/$1"
  fprint "$TMP/$1"
  rm -f "$TMP/$1"
}

fprint_addon() {
  fprint "$addons/$1"
}

update() {
    local bs restore flag xz gz ro
    restore=()
    while [[ $# -gt 0 ]]; do
      flag="$1"
      case $flag in
          -xz)
          xz=true
          shift
          ;;
          -gz)
          gz=true
          shift
          ;;
          *)   
          restore+=("$1")
          shift
          ;;
      esac
    done
    set -- "${restore[@]}"
    if is_number $(string remove M "$extraction_speed"); then bs=$extraction_speed; else bs=1048576; fi
    if exist "$2"; then
       blockdev --setrw "$2" 2>/dev/null
       ro=$(blockdev --getro "$2" 2>/dev/null)
       if [[ "$ro" == "1" ]]; then
          echo2 "FATAL ERROR: Read/Only: $2"
          if [[ "$3" == "1" ]]; then abort; else return 1; fi
       elif [[ "$ro" != "0" ]]; then
          echo2 "Cant get state: $2"
          echo2 "Skipping: Writing in: $2"
       fi
    fi
    if defined xz; then
       if xz -dc "$1" > "$2"; then
          echo2 " "
		  echo2 "-- Updated:xz: $(basename $1)"
		  echo2 " "
          return 0
       else
          echo2 " "
          echo2 "-- Cant update: $(basename $1)"
          echo2 " "
          if [[ "$3" == "1" ]]; then abort; else return 1; fi
       fi
    elif defined gz; then
       if gunzip -c "$1" > "$2"; then
          echo2 " "
		  echo2 "-- Updated:gz: $(basename $1)"
		  echo2 " "
          return 0
       else
          echo2 " "
          echo2 "-- Cant update: $(basename $1)"
          echo2 " "
          if [[ "$3" == "1" ]]; then abort; else return 1; fi
       fi
    fi
	if simg2img "$1" "$2"; then
        echo2 " "
		echo2 "-- Updated:simg: $(basename $1)"
		echo2 " "
	elif dd if="$1" of="$2" bs=$bs; then
        echo2 " "
		echo2 "-- Updated:1: $(basename $1)"
		echo2 " "
    elif cat "$1" > "$2"; then
        echo2 " "
		echo2 "-- Updated:2: $(basename $1)"
		echo2 " "
    else
        echo2 " "
        echo2 "-- Cant update: $(basename $1)"
        echo2 " "
        if [[ "$3" == "1" ]]; then abort; else return 1; fi
	fi
}

update_addon() {
    local restore flag xz gz
    restore=()
    while [[ $# -gt 0 ]]; do
      flag="$1"
      case $flag in
          -xz)
          xz="-xz"
          shift
          ;;
          -gz)
          gz="-gz"
          shift
          ;;
          *)   
          restore+=("$1")
          shift
          ;;
      esac
    done
    set -- "${restore[@]}"
    update $xz $gz "$addons/$1" "$2" "$3"
}

update_zip() {
    local bs restore flag xz gz
    restore=()
    while [[ $# -gt 0 ]]; do
      flag="$1"
      case $flag in
          -xz)
          xz=true
          shift
          ;;
          -gz)
          gz=true
          shift
          ;;
          *)   
          restore+=("$1")
          shift
          ;;
      esac
    done
    set -- "${restore[@]}"
    if is_number $(string remove M "$extraction_speed"); then bs=$extraction_speed; else bs=1048576; fi
    if exist "$2"; then
       blockdev --setrw "$2" 2>/dev/null
       ro=$(blockdev --getro "$2" 2>/dev/null)
       if [[ "$ro" == "1" ]]; then
          echo2 "FATAL ERROR: Read/Only: $2"
          if [[ "$3" == "1" ]]; then abort; else return 1; fi
       elif [[ "$ro" != "0" ]]; then
          echo2 "Cant get state: $2"
          echo2 "Skipping: Writing in: $2"
       fi
    fi
    if defined xz; then
       if unzip -p -o "$installzip" "$1" | xz -dc > "$2"; then
          echo2 " "
		  echo2 "-- Updated:xz: $(basename $1)"
		  echo2 " "
          return 0
       else
          echo2 " "
          echo2 "-- Cant update: $(basename $1)"
          echo2 " "
          if [[ "$3" == "1" ]]; then abort; else return 1; fi
       fi
    elif defined gz; then
       if unzip -p -o "$installzip" "$1" | gunzip -c - > "$2"; then
          echo2 " "
		  echo2 "-- Updated:gz: $(basename $1)"
		  echo2 " "
          return 0
       else
          echo2 " "
          echo2 "-- Cant update: $(basename $1)"
          echo2 " "
          if [[ "$3" == "1" ]]; then abort; else return 1; fi
       fi
    fi
	if unzip -p -o "$installzip" "$1" | dd of="$2" bs=$bs; then
        echo2 " "
		echo2 "-- Updated:1: $(basename $1)"
		echo2 " "
    elif unzip -p -o "$installzip" "$1" > "$2"; then
        echo2 " "
		echo2 "-- Updated:2: $(basename $1)"
		echo2 " "
    else
        echo2 " "
        echo2 "-- Cant update: $(basename $1)"
        echo2 " "
        if [[ "$3" == "1" ]]; then abort; else return 1; fi
	fi
}

get_file_prop() {
  grep -m1 "^$2=" "$1" | cut -d= -f2
}

set_progress() { if ! $BOOTMODE; then echo "set_progress $1" >> $OUTFD; fi }

ui_print() {
  until [ ! "$1" ]; do
     if ! $BOOTMODE; then
        if [ $(echo "$1" | wc -l) -gt 2 ]; then
           local IFS=$'\n' line
           for line in $1; do
             [ -n "$OUTFD" ] && echo "ui_print $line${n}ui_print" >> $OUTFD
             [ -z "$OUTFD" ] && echo "$line"
           done
        else
           [ -n "$OUTFD" ] && echo "ui_print $1${n}ui_print" >> $OUTFD
           [ -z "$OUTFD" ] && echo "$1"
        fi
     else 
       echo "$1"
     fi
     shift
  done
}

ch_con() {
  local con
  if [[ -n "$1" && -n "$2" ]]; then is_substring u:object "$1" && con=$1 || con=u:object_r:$1:s0; else return 1; fi
  shift
  while [ "$1" ]; do
    echo2 "set_context: $con in $1"
    chcon -h $con "$1" || chcon $con "$1"
    shift
  done
}

set_perm() {
  chown "$1:$2" "$4"
  chmod "$3" "$4"
}

set_perm2() {
  #Ensure this format
  chown "$1:$2" "$4"
  chmod "$3" "$4"
}

setup_mountpoint() {
  test -L $1 && mv -f $1 ${1}_link
  if [ ! -d $1 ]; then
    rm -f $1
    mkdir $1
  fi
}

is_mounted() { mount | grep -q " $(readlink -f "$1" 2>/dev/null) "; }

is_same_mount() {
   local try try2 eq eq2 path path2
   try=$(mount | grep -m1 " $(readlink -f "$1" 2>/dev/null) ")
   try2=$(mount | grep -m1 " $(readlink -f "$2" 2>/dev/null) ")
   eq=$(echo "$try" | awk '{ print $1; }')
   eq2=$(echo "$try2" | awk '{ print $1; }')
   path=$(echo "$try" | awk '{ print $3; }')
   path2=$(echo "$try2" | awk '{ print $3; }')
   if [[ "$eq" == "$eq2" ]]; then echo2 "[$path:$eq] == [$path2:$eq2]" && return 0; else echo2 "[$path:$eq] != [$path2:$eq2]" && return 1; fi
}

remove_tmp() {
   find "$TMP" -mindepth 1 ! -name "*.log" -delete > /dev/null
}

loop_setup() {
  loopdev=
  local loop
  local minorx=1
  [ -e /dev/block/loop1 ] && minorx=$(stat -Lc '%T' /dev/block/loop1)
  local num=0
  while [ $num -lt 64 ]; do
    loop=/dev/block/loop$num
    [ -e $loop ] || mknod $loop b 7 $((num * minorx))
    if losetup $loop "$1" 2>/dev/null; then
      loopdev=$loop
      break
    fi
    num=$((num + 1))
  done
}

mount_apex() {
  $BOOTMODE || [ ! -d /system/apex ] && return
  local apex dest linkerconfig pkg
  local list="$di_apex_list"
  delete "$list"
  setup_mountpoint /apex
  mount -t tmpfs tmpfs /apex -o mode=755
  for apex in /system/apex/* /system_ext/apex/*; do
    [ ! -e "$apex" ] && continue
    pkg=$(apex_pkg $apex 2>/dev/null)
    [ -z "$pkg" ] && continue
    if ! cat "$list" 2>/dev/null | grep -q "$pkg="; then apex_mount "$apex"; fi
  done
  export ANDROID_RUNTIME_ROOT=$(find /apex -type d -name "com.android.runtime*")
  export ANDROID_ART_ROOT=$(find /apex -type d -name "com.android.art*")
  export ANDROID_TZDATA_ROOT=$(find /apex -type d -name "com.android.tzdata*")
  export ANDROID_I18N_ROOT=$(find /apex -type d -name "com.android.i18n*")
  export ANDROID_DATA="$TMP/dalvik-cache"
  local APEXJARS=$(find /apex -name '*.jar' | sort | tr '\n' ':')
  local FWK=/system/framework
  delete_recursive "$ANDROID_DATA"
  mkdir -p "$ANDROID_DATA"
  export BOOTCLASSPATH=${APEXJARS}\
$FWK/framework.jar:$FWK/ext.jar:$FWK/telephony-common.jar:\
$FWK/voip-common.jar:$FWK/ims-common.jar:$FWK/telephony-ext.jar
  #Try mount/generate linkerconfig
  if can_run linkerconfig; then linkerconfig=linkerconfig
  elif can_run $ANDROID_RUNTIME_ROOT/bin/linkerconfig; then linkerconfig=$ANDROID_RUNTIME_ROOT/bin/linkerconfig
  elif can_run /system/bin/bootstrap/linkerconfig; then linkerconfig=/system/bin/bootstrap/linkerconfig
  else echo2 "DI: No linkerconfig"
  fi
  if defined linkerconfig; then
     genre_apex_list || echo2 "CANT GENERATE: apex-info-list.xml"
     echo2 " Mounting: /linkerconfig"
     setup_mountpoint /linkerconfig
     mkdir -p /linkerconfig/bootstrap
     mkdir -p /linkerconfig/default
     $linkerconfig --target /linkerconfig/bootstrap
     cp /linkerconfig/bootstrap/ld.config.txt /linkerconfig/default/ld.config.txt
     mount -o bind /linkerconfig/bootstrap /linkerconfig
     linkerconfig=$(find /linkerconfig -name '*.txt' | sort | tr '\n' ':')
     all_umount+=("/linkerconfig")
  fi
  export APEX_MOUNT_PASS=true
  echo2 "------------APEX INFO------------"
  for dest in ANDROID_RUNTIME_ROOT ANDROID_ART_ROOT \
  ANDROID_TZDATA_ROOT ANDROID_I18N_ROOT ANDROID_DATA \
  BOOTCLASSPATH DEX2OATBOOTCLASSPATH linkerconfig
  do
     if defined $dest; then echo2 "$dest=$(checkvar $dest)"; fi
  done
  echo2 "-----------------------------------"
}

apex_mount() {
    local apex="$1" dest loopdev
    local list="$di_apex_list"
    if [ -f "$apex" ]; then
         dest=
         dest=$(apex_pkg "$apex")
         [ ! -z "$dest" ] && dest=/apex/$dest || return 1
         [ -d "$dest" ] || mkdir -p "$dest"
         ( if unzip -l "$apex" original_apex | grep -q original_apex; then
            unzip -p "$apex" original_apex | unzip -qo - apex_payload.img -d /apex
         else unzip -qo "$apex" apex_payload.img -d /apex
         fi ) 2>/dev/null
         if [ ! -f /apex/apex_payload.img ]; then is_mounted "$dest" || delete_recursive "$dest"; return 1; fi
         loop_setup /apex/apex_payload.img
         if [ ! -z $loopdev ]; then
           echo "$(basename $dest)=$apex" >> "$list"
           echo2 " Mounting:file: $dest"
           mount -t ext4 -o ro,noatime $loopdev $dest
         fi
         rm -f /apex/apex_payload.img
    elif [ -d "$apex" ]; then
         dest=
         dest=$(apex_pkg "$apex")
         [ ! -z "$dest" ] && dest=/apex/$dest || return 1
         [ -d "$dest" ] || mkdir -p "$dest"
         echo "$(basename $dest)=$apex" >> "$list"
         echo2 " Mounting:folder: $dest" && mount -o bind "$apex" $dest
    fi
}

umount_apex() {
  test -d /apex || return
  local dest loop
  local list="$di_apex_list"
  for dest in $(cat "$list" | cut -d'=' -f1); do
    dest=/apex/$dest
    if [ -d $dest ]; then
       loop=$(mount |  grep $dest |  cut -d" " -f1)
       echo2 " Unmounting $dest "
       umount -ld $dest
       losetup -d $loop 2>/dev/null
    fi
  done
  umount -l /apex
  for dest in ANDROID_RUNTIME_ROOT ANDROID_ART_ROOT \
  ANDROID_TZDATA_ROOT ANDROID_I18N_ROOT ANDROID_DATA \
  BOOTCLASSPATH DEX2OATBOOTCLASSPATH
  do
     unset $dest
  done
}

genre_apex_list() {
   local module_path name apex list count=0
   local list2="$di_apex_list"
   [ -z "$1" ] && list=/apex/apex-info-list.xml || list="$1"
   echo '<?xml version="1.0" encoding="utf-8"?>' > "$list"
   echo '<apex-info-list>' >> "$list"
   for apex in $(cat "$list2" | cut -d'=' -f1); do
     apex=/apex/$apex
     if [ -d $apex ]; then
         name=$(basename $apex)
         module_path=$(get_file_prop "$list2" $name)
         if [ -e "$module_path" ]; then
            count=$(( $count + 1))
            echo " <apex-info moduleName=\"$name\" modulePath=\"$module_path\" preinstalledModulePath=\"$module_path\" isFactory=\"true\" isActive=\"true\" />" >> "$list"
         fi
     fi
   done
   echo '</apex-info-list>' >> "$list"
   if [[ -f "$list" && $count != 0 ]]; then return 0; else delete "$list" && return 1; fi
}

unlock_all() {
   #superrepack by @munjeni
   #unlock_all for Dynamic Installer by @BlassGO
   if ! can_run superrepack; then echo2 "FATAL ERROR: CANT LOAD superrepack" && return 1; fi
   local super try count=0 return=0 space current result
   local log=/data/unlock_all.log
   local log2=/data/local/tmp/script.log
   space="/data/superrepack" 
   current=${PWD}
   super=$(find_block -e super)
   [ -z "$super" ] && echo2 "unlock_all: CANT find super partition " && return 1
   delete_recursive "$space"
   delete "$log"
   mkdir -p "$space"
   if ! exist folder "$space"; then echo2 "super_rw: CANT make $space" && return 1; fi
   cd "$space"
   if is_number "$1"; then try="$1"; else try=5; fi
   startlog "$log"
   echolog '>>> Unlock_ALL On-Fly 1.0.0'
   echo2 " "
   echolog " -- Converting $super to RW..."
   echolog " "
   while true; do
      result=
      sleep 1
      [[ "$count" == "$try" ]] && echolog "FATAL ERROR: CANT ENSURE $super as RW with $count attemps" && return=1 && break
      echolog "unlock_all:Attempt: $count"
      count=$(($count + 1))
      superrepack "$super" >> "$log" 2>&1
      result=$?
      savelog "----------------script.log----------------"
      if exist "$log2"; then cat "$log2" >> "$log"; fi
      if [[ "$result" == "0" ]]; then
         if grep -q "Could not allocate block" "$log2"; then continue; else break; fi
      fi
   done
   cd "$current"
   delete_recursive "$space"
   return $return
}

unlock() {
   #superrepack by @munjeni
   #unlock for Dynamic Installer by @BlassGO
   if ! can_run superrepack; then echo2 "FATAL ERROR: CANT LOAD superrepack" && return 1; fi
   local super try count=0 return=0 space current result
   local log=/data/unlock.log
   local log2=/data/local/tmp/script.log
   space="/data/superrepack" 
   current=${PWD}
   super=$(find_block -e super)
   [ -z "$1" ] && echo2 "unlock: Invalid line" && return 1
   [ -z "$super" ] && echo2 "unlock: CANT find super partition " && return 1
   delete_recursive "$space"
   delete "$log"
   mkdir -p "$space"
   if ! exist folder "$space"; then echo2 "super_rw: CANT make $space" && return 1; fi
   cd "$space"
   if is_number "$2"; then try="$2"; else try=5; fi
   startlog "$log"
   echolog '>>> Unlock On-Fly 1.0.0'
   echo2 " "
   echolog " -- Converting:$1 in $super to RW..."
   echolog " "
   while true; do
      result=
      sleep 1
      [[ "$count" == "$try" ]] && echolog "FATAL ERROR: CANT ENSURE $1 as RW with $count attemps" && return=1 && break
      echolog "unlock:Attempt: $count"
      count=$(($count + 1))
      superrepack "$super" "$1" >> "$log" 2>&1
      result=$?
      savelog "----------------script.log----------------"
      if exist "$log2"; then cat "$log2" >> "$log"; fi
      if [[ "$result" == "0" ]]; then
         if grep -q "Could not allocate block" "$log2"; then continue; else break; fi
      fi
   done
   cd "$current"
   delete_recursive "$space"
   return $return
}

superrepack() {
   if ! can_run superrepack; then echo2 "FATAL ERROR: CANT LOAD superrepack" && return 1; fi
   if getprop | grep manufacturer | grep -qm1 samsung; then
      ( delete "$TMP/vbmeta.img"
      write_raw_image "$(find_block vbmeta)" "$TMP/vbmeta.img") > /dev/null 2>&1
   fi
   "$l/superrepack" "$@"
   if getprop | grep manufacturer | grep -qm1 samsung; then
      echo " -- Restoring vbmeta.img"
      is_valid "$TMP/vbmeta.img" && write_raw_image "$TMP/vbmeta.img" "$(find_block vbmeta)" > /dev/null 2>&1
   fi
}

get_virtual_points() {
   local LOOP point try super
   super=$(find_block -e super)
   if undefined super && [ -z "$1" ]; then echo2 "CANT FIND SUPER PARTITION" && return 1
   elif [ -n "$1" ] && ! checksuper "$1"; then echo2 "FATAL ERROR: Invalid SUPER: $1" && return 1
   fi
   [ -n "$1" ] && super="$1"
   echo2 '-- Loading virtual points... '
   for point in system vendor product odm system_ext; do
      try="$point$slot"
      start_loop "$try" "$super" 2>/dev/null
      if defined LOOP; then all_looped_loop+=("$LOOP") && echo2 "$point=$LOOP" && setdefault "$point" "$LOOP"; else echo2 "NO POINT: $point "; fi
   done
}

get_size_ext4() { string inside ',' 'bytes' "$(fdisk -l "$1" | grep -m1 "Disk")" | tr -d " "; }

get_offset() {
  #get_offset "partition name inside SUPER" "SUPER partition/image"
  local head offset
  if ! can_run superrepack; then echo2 "FATAL ERROR: CANT LOAD superrepack" && return 1; fi
  [[ -z "$1" || -z "$2" ]] && return 1
  head=$(string -r -p "$1" complete_extract "partition_" "Partition:" "$(superrepack "$2" noneeded 2>/dev/null)")
  offset=$(string inside "offset =" ')' "$(echo "$head" | grep "dumping offset")" | tr -d " ")
  offset=$(printf "%d\n" "$offset" 2>/dev/null || echo FAILED)
  if ! is_substring "FAILED" "$offset"; then echo "$offset" && return 0; else return 1; fi
}

get_size() {
  #get_size "partition name inside SUPER" "SUPER partition/image"
  local head size
  if ! can_run superrepack; then echo2 "FATAL ERROR: CANT LOAD superrepack" && return 1; fi
  [[ -z "$1" || -z "$2" ]] && return 1
  head=$(string -r -p "$1" complete_extract "partition_" "Partition:" "$(superrepack "$2" noneeded 2>/dev/null)")
  size=$(string inside '(' 'bytes total' "$(echo "$head" | grep "bytes total")" | tr -d " ")
  size=$(printf "%d\n" "$size" 2>/dev/null || echo FAILED)
  if ! is_substring "FAILED" "$size"; then echo "$size" && return 0; else return 1; fi
}

get_total_size() {
  #get_total_size "SUPER partition/image"
  local head size bytes total=0 error=0
  if ! can_run superrepack; then echo2 "FATAL ERROR: CANT LOAD superrepack" && return 1; fi
  [ -z "$1" ] && return 1
  while read bytes; do
     undefined bytes && break
     size=$(string inside '(' 'bytes total' "$bytes" | tr -d " ")
     size=$(printf "%d\n" "$size" 2>/dev/null || echo FAILED)
     if ! is_substring "FAILED" "$size"; then total=$(calc $total + $size); else error=$(($error + 1)); fi
  done <<< $(superrepack "$1" noneeded 2>/dev/null | grep "bytes total")
  if [[ "$error" == "0" ]] && is_number "$total" && is_greater "$total" 0; then echo "$total" && return 0; else return 1; fi
}

get_group() {
  #get_group "partition name inside SUPER" "SUPER partition"
  local head group
  if ! can_run superrepack; then echo2 "FATAL ERROR: CANT LOAD superrepack" && return 1; fi
  [[ -z "$1" || -z "$2" ]] && return 1
  head=$(string -r -p "$1" complete_extract "partition_" "Partition:" "$(superrepack "$2" noneeded 2>/dev/null)")
  group=$(echo "$head" | grep "partition_group" | cut -d'=' -f2 | tr -d " ")
  if defined group; then echo "$group" && return 0; else return 1; fi
}

checksuper() {
  #checksuper "SUPER partition/image"
  if ! can_run superrepack; then echo2 "FATAL ERROR: CANT LOAD superrepack" && return 1; fi
  [ -z "$1" ] && return 1
  if ! superrepack "$1" noneeded 2>/dev/null | grep -q "This is not super image"; then true; else false; fi
}

start_loop() {
    local loop=$(losetup2 -f) size offset
    if ! can_run superrepack; then echo2 "FATAL ERROR: CANT LOAD superrepack" && return 1; fi
    if ! can_run losetup2; then echo2 "FATAL ERROR: CANT LOAD losetup2" && return 1; fi
    if undefined loop; then echo2 "Cant make loop" && return 1; fi
    if ! checksuper "$2"; then echo2 "start_loop: Invalid SUPER: $2" && return 1; fi
    size=$(get_size "$1" "$2")
    offset=$(get_offset "$1" "$2")
    if ! defined size offset || ! is_number "$size" || ! is_number "$offset"; then echo2 "CANT GET INFO FROM: $2" && return 1; fi
    losetup2 --offset=$offset --sizelimit=$size $loop "$2"
    if losetup2 -a | grep -q "$loop"; then all_loopkskqiiq+=("$loop") && echo2 "$loop" && LOOP="$loop"; else return 1; fi
}

end_loop() {
   local i refresh
   LOOP=
   [[ -z "${all_loopkskqiiq[${#all_loopkskqiiq[@]} - 1]}" && -z "$1" ]] && return 1
   if [ -z "$1" ]; then
      losetup -d "${all_loopkskqiiq[${#all_loopkskqiiq[@]} - 1]}"
      unset "all_loopkskqiiq[${#all_loopkskqiiq[@]}-1]"
      for i in "${!all_loopkskqiiq[@]}"; do
         refresh+=("${all_loopkskqiiq[i]}")
      done
      all_loopkskqiiq=("${refresh[@]}")
   else
      losetup -d "$1"
   fi
}

unify_path() {
   local check eq1 eq2 only return=0
   touch "$2/testrw" 2>/dev/null
   if exist "$2/testrw"; then
      delete "$2/testrw"
   else
      echo "unify_path: $2 Read/Only or Invalid" && return 1
   fi
   while read check; do
      if is_substring " differ" "$check"; then
         eq1=$(string inside "Files " " and" "$check")
         eq2=$(string inside " and " " differ" "$check")
         if defined eq1 eq2 && exist "$eq1" "$eq2"; then
            echo2 "Replacing: $eq1 in $eq2"
            if ! copy "$eq1" "$eq2"; then echo2 "FATAL ERROR: Cant unify $eq1" && return=1; fi
         fi
      elif is_substring "Only in $1" "$check"; then
         only=$(string remove "Only in $1: " "$check")
         if defined only && exist "$1/$only"; then
            echo2 "Adding: $1/$only in $2/$only"
            if ! copy "$1/$only" "$2/$only"; then echo2 "FATAL ERROR: Cant unify $1/$only" && return=1; fi
         fi
      fi
   done <<< $(diff -qr "$1" "$2")
   return $return
}

super_rw() {
   #super_rw for Dynamic Installer by @BlassGO
   #superunpack by @munjeni
   #Inspired on @lebigmac systemrw project
   if ! can_run superrepack; then ui_print "FATAL ERROR: CANT LOAD superrepack" && return 1; fi
   if ! can_run superunpack; then ui_print "FATAL ERROR: CANT LOAD superunpack" && return 1; fi
   if ! can_run losetup2; then ui_print "FATAL ERROR: CANT LOAD losetup2" && return 1; fi
   local try count return=0 result block size size512 part newsize error reference all_blocks
   local restore flag force boot extract baseblock add add2 try in in2 custom custom512 test loop needed total free super LOOP
   local current=${PWD}
   local log=/data/super_rw.log
   local log2=/data/super_rw.tmp
   local space="/data/super_rw"
   local extra_space=100
   restore=()
   while [[ $# -gt 0 ]]; do
     flag="$1"
     case $flag in
         -f|-force)
         force=true
         shift
         ;;
         -b|-bootmode)
         boot=true
         shift
         ;;
         -s|-super)
         super="$2"
         shift 2
         ;;
         -a|-add)
         if is_substring "MB" "$2"; then add=$(string remove MB "$2" | awk '{print int($1 * 1024 * 1024)}'); else add="$2"; fi
         if ! is_number "$2" && ! is_greater "$2" 0; then ui_print "super_rw: Invalid line" && return 1; fi
         shift 2
         ;;
         -ai|-add-in)
         if [[ -z "$2" || -z "$3" ]]; then ui_print "super_rw: Invalid line" && return 1; fi
         in+=("$2")
         if is_substring "MB" "$3"; then
            test=$(string remove MB "$3" | awk '{print int($1 * 1024 * 1024)}')
            if is_number "$test" && is_greater "$test" 0; then in2+=("$test"); else ui_print "super_rw: Invalid line" && return 1; fi
         elif is_number "$3" && is_greater "$3" 0; then
            in2+=("$3")
         else
            ui_print "super_rw: Invalid line" && return 1
         fi
         shift 3
         ;;
         *)   
         restore+=("$1")
         shift
         ;;
     esac
   done
   set -- "${restore[@]}"
   [ -z "$super" ] && super=$(find_block -e super)
   [ -z "$super" ] && ui_print "super_rw: CANT find super partition " && return 1
   if ! checksuper "$super"; then ui_print "super_rw: Invalid SUPER: $super" && return 1; fi
   delete_recursive "$space"
   delete "$log"
   mkdir -p "$space"
   if ! exist folder "$space"; then ui_print "super_rw: CANT make $space" && return 1; fi
   cd "$space"
   startlog "$log"
   printlog '>>> Super_rw 1.0.0'
   #Mb to Bytes
   extra_space=$(calc $extra_space '* (1024^2)')
   #Total bytes + extra bytes
   total=$(calc $(get_total_size "$super") + $extra_space)
   #Bytes to GB
   needed=$(calc $total / '(1024^3)' )
   #Get free Kilobytes in space
   free=$(df -P "$space" | tail -1 | awk '{print $4}')
   #Kilobytes to GB
   free=$(calc $free / '(1024^2)')
   printlog " "
   printlog "super: $super "
   printlog "free_space: $free GB"
   printlog "needed_space: $needed GB"
   printlog " "
   #Check space
   if ! is_greater "$free" "$needed"; then printlog "super_rw: NO free space to extract SUPER image" && return 1; fi
   if undefined boot && $BOOTMODE && grep -q "^super_rw" "$TMP/updater-script" > /dev/null 2>&1; then
     ui_print " "
     ui_print "DI: Please install this ZIP with a Custom Recovery"
     ui_print "DI: This will allow the installer to unlock your partitions"
     ui_print " "
     $custom_mode && return 1 || abort
   elif undefined boot && $BOOTMODE; then
     ui_print " "
     ui_print "DI: Please add super_rw in the updater-script"
     ui_print "DI: Then install the ZIP with a Custom Recovery"
     ui_print "DI: This will allow the installer to unlock your partitions"
     ui_print " "
     $custom_mode && return 1 || abort
   fi
   printlog " -- Extracting:$super in $space..."
   superunpack "$super" 1 >> "$log" 2>&1
   while read part; do
         if undefined part; then printlog "FATAL ERROR: CANT FIND EXTRACTED IMGs" && break; fi
         count=0
         error=0
         size=
         size512=
         custom=
         custom512=
         baseblock=
         add2=
         baseblock=$(string remove ".ext4" "$(basename "$part")")
         if undefined baseblock; then printlog "FATAL ERROR: Cant get valid info from $part" && continue; fi
         if is_substring "shared_blocks" "$(tune2fs -l "$part" | grep "features")" || defined force; then
            printlog " -- Converting:$baseblock to RW..."
            size=$(get_size_ext4 "$part")
            size512=$(calc $size / 512)
            undefined size size512 && printlog "cant get size: $part" && continue
            printlog "$baseblock:size: $size"
            printlog "$baseblock:size512: $size512"
            newsize=$(calc '('$size' * 1.25) / 512')
            savelog "CALCULATED:$newsize"
            if ! resize2fs -f "$part" $newsize"s" >> "$log" 2>&1; then error=$(($error + 1)) && printlog "some error: resizing $part"; fi
            savelog " UNSHARING BLOCKS "
            e2fsck -y -E unshare_blocks "$part" >> "$log" 2>&1
            if is_substring "shared_blocks" "$(tune2fs -l "$part" | grep "features")"; then error=$(($error + 1)) && printlog "some error: unsharing block $part"; fi
            savelog " SHRINKING: MINIMUN SIZE"
            if ! resize2fs -f -M "$part" >> "$log" 2>&1; then error=$(($error + 1)) && printlog "some error: shrinking $part"; fi
            if is_less "$(get_size_ext4 "$part")" "$size"; then
               savelog " RESTORING SIZE "
               if ! resize2fs -f "$part" $size512"s" >> "$log" 2>&1; then error=$(($error + 1)) && printlog "some error: resizing $part"; fi
            fi
            if defined add; then
               size=$(get_size_ext4 "$part")
               custom=$(calc $size + $add)
               custom512=$(calc $custom / 512)
               printlog "$baseblock:custom_size: $custom"
               printlog "$baseblock:custom_size512: $custom512"
               if ! resize2fs -f "$part" $custom512"s" >> "$log" 2>&1; then error=$(($error + 1)) && printlog "some error: resizing $part"; fi
            fi
            if defined in; then
               for i in "${!in[@]}"; do
                  if is_substring "${in[i]}" "$baseblock"; then add2=${in2[i]} && break; fi
               done
               if defined add2; then
                  size=$(get_size_ext4 "$part")
                  custom=$(calc $size + $add2)
                  custom512=$(calc $custom / 512)
                  printlog "$baseblock:custom_size: $custom"
                  printlog "$baseblock:custom_size512: $custom512"
                  if ! resize2fs -f "$part" $custom512"s" >> "$log" 2>&1; then error=$(($error + 1)) && printlog "some error: resizing $part"; fi
               fi
            fi
            savelog " EXTRA FIX"
            e2fsck -fy "$part" >> "$log" 2>&1
            start_loop "$baseblock" "$super"
            loop="$LOOP"
            if ! defined loop; then echolog "some error: looping $block" && continue; fi
            printlog "$baseblock:loop: $loop"
            printlog " -- Unifying:$baseblock with $loop"
            try_mount -f "$loop" /mnt/stock_part
            try_mount -f "$part" /mnt/new_part
            if ! unify_path /mnt/stock_part /mnt/new_part >> "$log" 2>&1; then error=$(($error + 1)) && printlog "some error: unifying $part"; fi
            unmount /mnt/stock_part
            unmount /mnt/new_part
            printlog " -- Updating:$baseblock..."
            dd if="$part" of="$loop" bs=1M >> "$log" 2>&1
            losetup2 -c "$loop" >> "$log" 2>&1
            savelog " FINISHING"
            ( blockdev --setrw "$loop"
            end_loop "$loop" ) >> "$log" 2>&1
            size=$(get_size_ext4 "$part")
            size512=$(calc $size / 512)
            printlog "$baseblock:newsize: $size"
            printlog "$baseblock:newsize512: $size512"
            printlog "$baseblock:ended_with_error:$error"
            savelog "$(tune2fs -l "$part" | grep "features")"
            if [[ "$error" != "0" ]]; then return=1; fi
            printlog " "
        else
            printlog " -- Skipping:$baseblock..." && continue
        fi
        echo2 " "
   done <<< $(find "$space" -mindepth 1 -maxdepth 1 -type f -name "*.ext4")
   cd "$current"
   savelog " -- Wiping..."
   delete_recursive "$space"
   endlog
   return $return
}

ensure_root() {
   local fail=0
   mount -o rw,remount -t auto / 2>/dev/null
   try_mount -rw -n system /system_root
   is_mounted /system_root && touch /system_root/rwtest
   if exist /system_root/rwtest /system_root/etc; then delete /system_root/rwtest && return; fi
   if [[ "$virtual_partitions" == "true" ]]; then
      ui_print " "
      ui_print 'DI: Virtual partitions (Read/Only)...'
      ui_print "DI: Your partitions are locked..."
      ui_print 'DI: You need to run "super_rw" at least once'
      ui_print 'DI: Please add "super_rw" in the updater-script'
      ui_print " "
      abort " "
   fi
   #Check rw (in case manual mode is changed to automatic)
   try_mount -rw -n system /system_root
   is_mounted /system_root && touch /system_root/rwtest
   if exist /system_root/rwtest /system_root/etc; then
      delete /system_root/rwtest && return
   elif [[ "$virtual_partitions" == "true" ]]; then
      ui_print " WARNING: Dynamic Installer CANT CHANGE your SUPER image to Read/Write, please check the log"
      if is_valid /data/superunpack.log; then
         echo2 "Check: /data/superunpack.log"
      elif is_valid /data/super_rw.log; then
         echo2 "Check: /data/super_rw.log"
      else
         echo2 " ERROR: CANT FIND VALID LOG"
      fi
      $custom_mode && return 1 || abort
   else
      echo2 " ENSURE_ROOT: FAILED " && return 1
   fi
}

mount_all() {
  local runtime dest part block
  if ! is_mounted /data; then
     mount /data
    UMOUNT_DATA=1
  fi
  #Ensure root space
  mount -o rw,remount -t auto / 2>/dev/null
  (mount /cache
  mount -o ro -t auto /persist
  mount -o ro -t auto /product
  mount -o ro -t auto /vendor
  mount -o ro -t auto /system_ext) 2>/dev/null
  setup_mountpoint $ANDROID_ROOT
  if ! is_mounted $ANDROID_ROOT; then
    mount -o ro -t auto $ANDROID_ROOT 2>/dev/null
  fi
  case $ANDROID_ROOT in
    /system_root) setup_mountpoint /system;;
    /system)
      if ! is_mounted /system && ! is_mounted /system_root; then
        setup_mountpoint /system_root
        mount -o ro -t auto /system_root
      elif [ -f /system/system/build.prop ]; then
        setup_mountpoint /system_root
        mount --move /system /system_root
      fi
      if [ $? != 0 ]; then
        umount /system
        umount -l /system 
        if [ "$dynamic_partitions" = "true" ]; then
          mount -o ro -t auto /dev/block/mapper/system$slot /system_root
          for part in system_ext vendor product; do
             block=/dev/block/mapper/$part$slot
             if [ -e $block ]; then
                [ -d /$part ] || mkdir -p /$part
                mount -o ro -t auto $block /$part
             fi
          done
        else
          mount -o ro -t auto /dev/block/bootdevice/by-name/system$slot /system_root
        fi
      fi
    ;;
  esac
  if is_mounted /system_root; then
    if [ -f /system_root/build.prop ]; then
      mount -o bind /system_root /system
    else
      mount -o bind /system_root/system /system
    fi
    if [ -f /system/system_ext/build.prop ]; then
      setup_mountpoint /system_ext
      mount -o bind /system/system_ext /system_ext
    fi
  fi
}

umount_all() {
  local part umount post extra result=0 loop restore
  (if $BOOTMODE; then
     for umount in /system_ext /vendor /product; do
         if ! contains_array "$umount" "${all_umount[@]}"; then all_umount+=("$umount"); fi
     done
     if is_mounted /system_root && is_mounted /system; then
        if is_mounted /system_ext; then
           echo2 " Unmounting /system_ext "
           umount /system_ext || result=1
        fi
        echo2 " Unmounting /system "
        umount /system || result=1
     fi
     echo2 " Unmounting /system_root "
     unmount /system_root || unmount /system_root
     if is_mounted /system_root; then echo2 " CANT UNMOUNT: /system_root" && result=1; fi
     for loop in "${all_looped[@]}"; do
       echo2 " Unmounting $loop "
       umount -ld "$loop" 2>/dev/null
       if is_mounted "$loop"; then echo2 " CANT UNMOUNT: $loop" && result=1; fi
     done
     for loop in "${all_looped_loop[@]}"; do
       losetup -d "$loop" 2>/dev/null
     done
     for part in "${all_umount[@]}"; do
        if is_mounted "$part"; then
           try_mount -ro "$part" || try_mount -remount -ro "$part" || echo2 " CANT REMOUNT: $part as RO "
        fi
     done
     for restore in "${all_umount[@]}" "${all_looped[@]}"; do
       if [ -L "${restore}_link" ]; then
          rmdir "$restore"
          mv -f "${restore}_link" "$restore"
       fi
     done
  else
     for umount in /system_ext /system /system_root /cache /persist /vendor /product; do
         if ! contains_array "$umount" "${all_umount[@]}"; then all_umount+=("$umount"); fi
     done
     $APEX_MOUNT_PASS && umount_apex
     for part in "${all_umount[@]}"; do
       echo2 " Unmounting $part "
       unmount "$part" || post+=("$part")
     done
     for loop in "${all_looped[@]}"; do
       echo2 " Unmounting $loop "
       umount -ld "$loop" 2>/dev/null || post+=("$loop")
     done
     for loop in "${all_looped_loop[@]}"; do
       losetup -d "$loop" 2>/dev/null
     done
     for extra in "${post[@]}"; do
        unmount "$extra"
        if is_mounted "$extra"; then echo2 " CANT UNMOUNT: $extra" && result=1; fi
     done
     for restore in /apex "${all_umount[@]}" "${all_looped[@]}"; do
       if [ -L "${restore}_link" ]; then
          rmdir "$restore"
          mv -f "${restore}_link" "$restore"
       fi
     done
  fi
  mount -o rw,remount -t auto / 2>/dev/null
  if $BOOTMODE; then is_mounted /system_root || rm -rf /system_root; fi
  $BOOTMODE && mount -o ro,remount -t auto / 2>/dev/null
  if [ "$UMOUNT_DATA" ]; then
    umount /data
    umount -l /data
  fi)
  $BOOTMODE || umount -l /dev/random 2>/dev/null
  return $result
}

destroy_env() {
   [ -z "$OLD_LD_PATH" ] && OLD_LD_PATH="$LD_LIBRARY_PATH"
   [ -z "$OLD_LD_PRELOAD" ] && OLD_LD_PRELOAD="$LD_PRELOAD"
   [ -z "$OLD_LD_CONFIG" ] && OLD_LD_CONFIG="$LD_CONFIG_FILE"
   unset LD_LIBRARY_PATH
   unset LD_PRELOAD
   unset LD_CONFIG_FILE
}

restore_env() {
  [ -n "$OLD_LD_PATH" ] && export LD_LIBRARY_PATH="$OLD_LD_PATH"
  [ -n "$OLD_LD_PRELOAD" ] && export LD_PRELOAD="$OLD_LD_PRELOAD"
  [ -n "$OLD_LD_CONFIG" ] && export LD_CONFIG_FILE="$OLD_LD_CONFIG"
}

dynamic_install(){
   local f inst_dir
   while read f; do
     undefined f && break
     inst_dir=$(dirname "$f")
     inst_dir=${inst_dir#$1}
     inject "$f" "$2${inst_dir}"
   done <<< $(find "$1" -mindepth 1 -type f)
}
	
inject() {
  local file dest
  file=$(basename "$1")
  dest="$2/$file"
  if [ ! -d "$2" ]; then mkdir -p "$2"; fi
  if install -D "$1" "$dest" >/dev/null 2>&1; then
     set_perm2 0 0 644 "$dest"
     set_perm2 0 0 755 "$2"
  elif cp -prf "$1" "$dest"; then
     set_perm2 0 0 644 "$dest"
     set_perm2 0 0 755 "$2"
  else
     echo2 "Cant inject: $file"
  fi
}

auto_mount_partitions() {
    local main block extra noexist
    if ! $BOOTMODE; then
      mount -o bind /dev/urandom /dev/random
      umount_all
      mount_all
    fi
    if [ "$dynamic_partitions" = "true" ]; then
       find /dev/block/mapper -mindepth 1 -maxdepth 1 \( -type b -o -type c -o -type l \) | while read block; do
          if undefined block; then echo2 "WARNING: CANT FIND /dev/block/mapper partitions" && break; fi
          blockdev --setrw "$block"
       done
    fi
    #Ensure root space
    ensure_root
    if $BOOTMODE; then
       if ! is_mounted /system_root; then
          try_mount -n system /system_root
       fi
       if is_mounted /system_root; then
          if [ -f /system_root/build.prop ]; then
            mount -o bind /system_root /system
          else
            mount -o bind /system_root/system /system
          fi
          if [ -f /system/system_ext/build.prop ]; then
             mount -o bind /system/system_ext /system_ext
          fi
       else
          echo2 " CANT ENSURE: /system_root "
       fi
       for extra in system_ext vendor product; do
          if exist $(find /dev/block \( -type b -o -type c -o -type l \) -iname "$extra" -o -iname "$extra$slot" | head -n1 ); then
             try_mount "/$extra" || try_mount -remount "/$extra"
          fi
       done
    else
       for main in system system_ext vendor product; do
          if ! is_mounted "/$main"; then
             if [[ "$main" == "system" ]]; then 
                try_mount -remount -n system /system_root
                if is_mounted /system_root; then
                   setup_mountpoint /system
                   if [ -f /system_root/build.prop ]; then
                      mount -o bind /system_root /system
                   else
                      mount -o bind /system_root/system /system
                   fi
                   if [ -f /system/system_ext/build.prop ]; then
                      setup_mountpoint /system_ext
                      mount -o bind /system/system_ext /system_ext
                   fi
                else
                   echo2 " CANT ENSURE: /system_root "
                fi
             else
                if exist $(find /dev/block \( -type b -o -type c -o -type l \) -iname "$main" -o -iname "$main$slot" | head -n1); then
                   try_mount -remount "/$main"
                else
                   noexist+=("$main")
                fi
             fi
             if contains_array "$main" "${noexist[@]}"; then
                echo2 " No block: $main "
             elif ! is_mounted "/$main"; then
                echo2 " CANT MOUNT: /$main "
             fi
          fi
       done
    fi
    if [[ -n "$apex_mount" && "$apex_mount" != "off" ]]; then 
       $BOOTMODE || mount_apex
    elif ! $BOOTMODE; then
       runtime=$(find /system/apex -name "com.android.runtime*" -print | head -n 1)
       [[ -z "$runtime" && -d /system_ext/apex ]] && runtime=$(find /system_ext/apex -name "com.android.runtime*" -print | head -n 1)
       if [ -z "$runtime" ]; then echo2 "FATAL ERROR: Cant find RUNTIME"
       else apex_mount "$runtime"
       fi
    fi
    ( mount -o rw,remount -t auto /system || mount -o rw,remount -t auto /
    mount -o rw,remount -t auto /vendor 
    mount -o rw,remount -t auto /product
    mount -o rw,remount -t auto /system_ext ) 2>/dev/null
    #Extra RW for /system_root
    mount -o remount,rw /system_root
}
if [ -z "$BOOTMODE" ]; then
   ps | grep zygote | grep -v grep >/dev/null && export BOOTMODE=true || export BOOTMODE=false
   $BOOTMODE || ps -A  | grep zygote | grep -v grep >/dev/null && export BOOTMODE=true
fi
test "$ANDROID_ROOT" || ANDROID_ROOT=/system
getarch

export APEX_MOUNT_PASS=false
export custom_mode=false
export n=$'\n'
export yes=chooseport
export MYPATH="$1"

#Recovery Mode Implementation
if [[ -z "$installzip" && "$BOOTMODE" == "false" ]]; then
   export custom_mode=true
   export apex_mount=true
   if undefined TMPDIR Dynamic_Setup; then export TMP=/tmp; else export TMP="$TMPDIR"; fi
   export l="$TMP/ugu"
   export addons="$TMP/addons"
   echo " >> Recovery Mode 1.0.0 "
   echo " @BlassGO "
   echo " "
   defined MYPATH && echo " -- Working from: $MYPATH"
   echo " -- Loading environment..."
   delete_recursive "$l"
   delete_recursive "$addons"
   if ! exist "$l"; then mkdir -p "$l"; fi
   echo
fi

#Test Mode (Maintenance or just testing for Devs)
if [[ -z "$installzip" && "$BOOTMODE" == "true" ]]; then
   export custom_mode=true
   export PATH="/data/data/com.termux/files/usr/bin:/data/data/com.termux/files/usr/bin/applets:/sbin:/sbin/su:/su/bin:/su/xbin:/system/bin:/system/xbin:$PATH"
   echo " >> Test Mode 1.6.0 "
   echo " @BlassGO "
   echo " "
   defined MYPATH && echo " -- Working from: $MYPATH"
   echo " -- Loading environment..."
   if defined TMPDIR Dynamic_Setup; then export TMP="$TMPDIR"
   elif exist /data; then export TMP=/data/tmp
   else export TMP="${PWD}/tmp"
   fi
   export addons="$TMP/addons"
   export l="$TMP/ugu"
   delete_recursive "$TMP" >/dev/null 2>&1
   if ! exist "$l"; then mkdir -p "$l"; fi
   echo
fi

#CUSTOM MODES (Generic Setup)
if [[ "$custom_mode" == "true" ]]; then
   setenforce 0 2>/dev/null
   if exist "$MYPATH/busybox" "$MYPATH/bin"; then
      copy "$MYPATH/bin" "$TMP/bin.xz"
      copy "$MYPATH/busybox" "$TMP"
   elif exist busybox bin; then
      copy busybox "$TMP"
      copy bin "$TMP/bin.xz"
   else
      echo "ERROR: CANT FIND BUSYBOX or BIN"
      exit 1
   fi
   delete_recursive "$TMP/zbin"
   if ! exist "$TMP/zbin"; then mkdir -p "$TMP/zbin"; fi
   bb="$TMP/busybox"
   bin="$TMP/bin.xz"
   chmod 777 "$bb"
   chmod 777 "$bin"
   setup_bb
   export PATH="$l:$PATH"
   xz -d "$bin" >/dev/null 2>&1
   if ! exist file "$TMP/bin"; then echo "ERROR: CANT EMULATE BIN" && exit 1; fi;
   unzip -qo "$TMP/bin" -d "$TMP/zbin"
   find "$TMP/zbin" -type f -exec mv -f {} "$l" \;
   find "$l" -type f -exec chmod 777 {} +;
   #Remove invalid PATHs
   unset refresh
   while read valid; do
      if ! is_substring "$valid" "$refresh"; then
         refresh+="$valid:"
      fi
   done <<< $(split_string : "$PATH")
   if defined refresh; then export PATH="$refresh"; fi
fi

#Get AVB state
#getsecurity

#Checking TMP2 (For Dual functions operations)
start_tmp
if [ ! -d "$TMP2" ]; then abort "CANT SETUP: TMP2"; fi
tmp2="$TMP2"
end_tmp
if [ -d "$tmp2" ]; then abort "CANT SETUP:2: TMP2"; fi
unset tmp2

#Extra environment vars
export di_apex_list="$TMP/apex_list_0001.txt"

#Checking possible exceptions (Read/Only Functions)
pattern=off_readonly
eval "$pattern() { :; }"
if defined installzip; then
   while read ole; do
      undefined ole && break
      exception+=("$ole")
   done <<< $(split_string " " "$(string -r remove "$pattern " "$(
   package_extract_file META-INF/com/google/android/updater-script | grep "^$pattern "
   package_extract_file META-INF/com/google/android/magisk/customize.sh | grep "^$pattern "
   package_extract_file META-INF/com/google/android/magisk/install.sh | grep "^$pattern "
   )"
   )"
   )
fi
unset pattern ole

#Ensuring Dynamic Installer functions
for func in $(declare -F 2>/dev/null | awk '{ print $3; }'); do
   if contains_array "$func" "${exception[@]}" 2>/dev/null; then echo2 "readonly:off: $func"; else readonly -f $func 2>/dev/null; fi
done
unset func

#Ensuring Dynamic Installer vars
vars="TMP TMPDIR OUTFD installzip addons l n yes di_apex_list"
for var in $vars; do
   if contains_array "$var" "${exception[@]}" 2>/dev/null; then echo2 "readonly:off: $var"; else undefined $var || readonly $var 2>/dev/null; fi
done
unset vars var exception

#Load Virtual points
#get_virtual_points

#Destroy Recovery env
$BOOTMODE || destroy_env

#Check Custom Mode
if [[ "$custom_mode" == "true" ]]; then return; fi

# Pre-setup
package_extract_file META-INF/com/google/android/updater-script "$TMP/updater-script"
package_extract_dir META-INF/addons "$addons"
chmod 777 "$TMP/updater-script"
devices=$(getdefault "$TMP/updater-script" devices)
apex_mount=$(getdefault "$TMP/updater-script" apex_mount)
magisk_support=$(getdefault "$TMP/updater-script" magisk_support)
extraction_speed=$(getdefault "$TMP/updater-script" extraction_speed)
if [[ -n "$devices" && "$devices" != "off" ]]; then
    dcount=0
    setdefault may "
    $(getprop ro.product.device 2>/dev/null) 
    $(getprop ro.build.product 2>/dev/null) 
    $(getprop ro.product.vendor.device 2>/dev/null) 
    $(getprop ro.vendor.product.device 2>/dev/null)
    $(get_file_prop /default.prop ro.product.device 2>/dev/null)
    $(getprop ro.product.model 2>/dev/null) 
    $(grep_cmdline androidboot.em.model 2>/dev/null) 
    "
    while read huh; do
       undefined huh && continue
       while read ugu; do
         undefined ugu && continue
         if [[ "$huh" == "$ugu" ]]; then
            dcount=$(($dcount + 1))
            echo2 "[$ugu] == [$huh]"
         else
            echo2 "[$ugu] != [$huh]"
         fi
       done <<< $(split_string '' "$may")
    done <<< $(split_string : "$devices")
    if [[ "$dcount" == "0" ]]; then abort " -- Incompatible device: Its only for $(string -r replace : ' and ' "$devices" || echo "$devices")"; fi;
fi
unset may huh ugu dcount

if $BOOTMODE && [[ "$magisk_support" != "on" ]]; then
   if ! exist "$TMP"; then abort "FATAL ERROR: Cant find $TMP"; fi
   echo2 "----------------Running SCRIPTs------------"
   . "$TMP/updater-script"
   if [[ "$run_addons" == "on" ]]; then
     while read addon; do
        if exist "$addon"; then . "$addon"; fi
     done <<< $(find "$addons" -mindepth 1 -maxdepth 1 -type f -name "*.sh")
   fi
   remove_tmp
   echo2 "-------------------------------------------"
   exit 0
fi

if ! $BOOTMODE; then
echo2 "----------------Running SCRIPTs------------"
. "$TMP/updater-script"
if [[ "$run_addons" == "on" ]]; then
    while read addon; do
       if exist "$addon"; then . "$addon"; fi
    done <<< $(find "$addons" -mindepth 1 -maxdepth 1 -type f -name "*.sh")
fi
remove_tmp
restore_env
echo2 "-------------------------------------------"

else

require_new_magisk() {
    ui_print "*******************************"
    ui_print " Please install Magisk v19.0+! "
    ui_print "*******************************"
    abort
}

magisk_print() {
  ui_print "----------------------------------------"
  ui_print ' >>> Powered by Magisk '$MAGISK_VER_CODE
  ui_print "----------------------------------------"
  ui_print " "
}

mount /data 2>/dev/null

[ -f /data/adb/magisk/util_functions.sh ] || require_new_magisk
. /data/adb/magisk/util_functions.sh
[ $MAGISK_VER_CODE -lt 19000 ] && require_new_magisk

is_legacy_script() {
  unzip -l "$ZIPFILE" $DNM/install.sh | grep -q install.sh
  return $?
}

setup_flashable() {
  $BOOTMODE && return
  if [ -z $OUTFD ] || readlink /proc/$$/fd/$OUTFD | grep -q /tmp; then
    # We will have to manually find out OUTFD
    for FD in `ls /proc/$$/fd`; do
      if readlink /proc/$$/fd/$FD | grep -q pipe; then
        if ps | grep -v grep | grep -qE " 3 $FD |status_fd=$FD"; then
          OUTFD=$FD
          break
        fi
      fi
    done
  fi
  recovery_actions
}


install_module() {
  
  cd $TMPDIR

  setup_flashable
  mount_partitions
  api_level_arch_detect
  
  # Setup busybox and binaries
  if $BOOTMODE; then
    boot_actions
  else
    recovery_actions
  fi
  
  # Extract prop file
  package_extract_file $DNM/module.prop $TMPDIR/module.prop
  [ ! -f $TMPDIR/module.prop ] && abort "! Unable to extract zip file!"
  
  local MODDIRNAME=modules
  $BOOTMODE && MODDIRNAME=modules_update
  local MODULEROOT=$NVBASE/$MODDIRNAME
  MODID=`grep_prop id $TMPDIR/module.prop`
  MODNAME=`grep_prop name $TMPDIR/module.prop`
  MODAUTH=`grep_prop author $TMPDIR/module.prop`
  MODPATH=$MODULEROOT/$MODID

  # Create mod paths
  rm -rf $MODPATH
  mkdir -p $MODPATH

  if is_legacy_script; then
    package_extract_dir $DNM $TMPDIR
    # Load install script
    magisk_print
    . $TMPDIR/install.sh

    # Callbacks
    on_install

    [ -f $TMPDIR/uninstall.sh ] && cp -af $TMPDIR/uninstall.sh $MODPATH/uninstall.sh
    $SKIPMOUNT && touch $MODPATH/skip_mount
    $PROPFILE && cp -af $TMPDIR/system.prop $MODPATH/system.prop
    cp -af $TMPDIR/module.prop $MODPATH/module.prop
    $POSTFSDATA && cp -af $TMPDIR/post-fs-data.sh $MODPATH/post-fs-data.sh
    $LATESTARTSERVICE && cp -af $TMPDIR/service.sh $MODPATH/service.sh

    set_permissions
  else
    magisk_print

    package_extract_file $DNM/customize.sh $MODPATH/customize.sh

    if ! grep -q '^SKIPUNZIP=1$' $MODPATH/customize.sh 2>/dev/null; then
      package_extract_dir $DNM $MODPATH

      # Default permissions
      echo2 "- Setting common permissions/contexts"
      echo2 " "
      set_perm_recursive2 0 0 0755 0644 $MODPATH
      ch_con_recursive system_file system_file $MODPATH
      for perm in /system/bin /system/xbin /system/system_ext/bin /system/vendor/bin; do
         if [ -d "$MODPATH$perm" ]; then
            set_perm_recursive2 0 2000 0755 0755 "$MODPATH$perm"
         fi
      done
      if [ -d "$MODPATH/system/vendor" ]; then ch_con_recursive vendor_file vendor_file "$MODPATH/system/vendor"; fi
      unset perm
    fi

    # Load customization script
    [ -f $MODPATH/customize.sh ] && . $MODPATH/customize.sh
  fi

  # Handle replace folders
  for TARGET in $REPLACE; do
    echo2 "- Replace target: $TARGET"
    mktouch $MODPATH$TARGET/.replace
  done

  if $BOOTMODE; then
    # Update info for Magisk app
    mktouch $NVBASE/modules/$MODID/update
    rm -rf $NVBASE/modules/$MODID/remove 2>/dev/null
    rm -rf $NVBASE/modules/$MODID/disable 2>/dev/null
    cp -af $MODPATH/module.prop $NVBASE/modules/$MODID/module.prop
  fi

  # Copy over custom sepolicy rules
  if [ -f $MODPATH/sepolicy.rule ]; then
    echo2 "- Installing custom sepolicy rules"
    copy_sepolicy_rules
  fi

  # Remove stuff that doesn't belong to modules and clean up any empty directories
  rm -rf \
  $MODPATH/system/placeholder $MODPATH/customize.sh \
  $MODPATH/README.md $MODPATH/.git*
  rmdir -p $MODPATH

  cd /
  if [[ "$run_addons" == "on" ]]; then
    while read addon; do
       if exist "$addon"; then . "$addon"; fi
    done <<< $(find "$addons" -mindepth 1 -maxdepth 1 -type f -name "*.sh")
  fi
  $BOOTMODE || recovery_cleanup
  rm -rf $TMPDIR

}

if [ $MAGISK_VER_CODE -ge 20400 ]; then
  # New Magisk have complete installation logic within util_functions.sh
  echo2 "----------------Running SCRIPTs------------"
  install_module
  restore_env
  echo2 "-------------------------------------------"
  exit 0
fi

fi

